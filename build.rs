// build.rs
//
// NOTE IT IS *IMPORTANT* THAT THIS FILE CORRECTLY READS extensions/
// DO NOT JUST HARDCODE EXTENSIONS IN THIS FILE!!!!

use std::{env, fs, path::Path};

fn sanitize_ident(stem: &str) -> String {
    let mut s: String = stem
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect();
    if s.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
        s.insert(0, '_');
    }
    if s.is_empty() {
        s = "_".into();
    }
    s
}


fn main() -> std::io::Result<()> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let extensions_dir = Path::new(&manifest_dir).join("extensions");
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_extensions.rs");

    let mut expand_entries = Vec::new();
    let mut bin_entries = Vec::new();
    let mut root_entries = Vec::new();
    let mut admin_entries = Vec::new();

    if extensions_dir.exists() {
        for entry in fs::read_dir(&extensions_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_file() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.ends_with(".expand.rs") {
                        let stem = &name[..name.len() - ".expand.rs".len()];
                        let ident = sanitize_ident(stem);
                        expand_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".bin.rs") {
                        let stem = &name[..name.len() - ".bin.rs".len()];
                        let ident = sanitize_ident(stem);
                        bin_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".root.rs") {
                        let stem = &name[..name.len() - ".root.rs".len()];
                        let ident = sanitize_ident(stem);
                        root_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".admin.rs") {
                        let stem = &name[..name.len() - ".admin.rs".len()];
                        let ident = sanitize_ident(stem);
                        admin_entries.push((ident, name.to_string()));
                    }
                }
            }
        }
    }

    expand_entries.sort_by(|a, b| a.0.cmp(&b.0));
    bin_entries.sort_by(|a, b| a.0.cmp(&b.0));
    root_entries.sort_by(|a, b| a.0.cmp(&b.0));
    admin_entries.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Auto-generated by build.rs. Do not edit.\n\n");

    // Generate expand extensions
    for (ident, filename) in expand_entries {
        out.push_str(&format!(
            "mod {ident} {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate bin extensions
    for (ident, filename) in bin_entries {
        out.push_str(&format!(
            "mod {ident}_bin {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate root extensions
    for (ident, filename) in root_entries {
        out.push_str(&format!(
            "mod {ident}_root {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate admin extensions
    for (ident, filename) in &admin_entries {
        out.push_str(&format!(
            "mod {ident}_admin {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate ExtensionRegistry
    out.push_str("pub struct ExtensionRegistry {\n");
    out.push_str("    // Extension registry implementation\n");
    out.push_str("}\n\n");

    out.push_str("impl ExtensionRegistry {\n");
    out.push_str("    pub fn new() -> Self {\n");
    out.push_str("        Self {\n");
    out.push_str("            // Initialize extension registry\n");
    out.push_str("        }\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn process_html(&self, html: &str, url: &str) -> String {\n");
    out.push_str("        // Process HTML with extensions\n");
    out.push_str("        html.to_string()\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn is_valid_admin_key(&self, key: &str) -> bool {\n");
    out.push_str("        // Validate admin key\n");
    out.push_str("        false\n");
    out.push_str("    }\n\n");

    out.push_str("    pub async fn process_admin_request(&self, path: &str, query: &str, body: &str, headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Process admin request\n");
    out.push_str("        Ok(r#\"{\\\"error\\\": \\\"Admin features not available\\\"}\"#.to_string())\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(&dest_path, out)?;
    println!("cargo:rerun-if-changed=extensions");
    Ok(())
}
