// build.rs
//
// NOTE IT IS *IMPORTANT* THAT THIS FILE CORRECTLY READS extensions/
// DO NOT JUST HARDCODE EXTENSIONS IN THIS FILE!!!!

use std::{env, fs, path::Path};

fn sanitize_ident(stem: &str) -> String {
    let mut s: String = stem
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect();
    if s.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
        s.insert(0, '_');
    }
    if s.is_empty() {
        s = "_".into();
    }
    s
}


fn main() -> std::io::Result<()> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let extensions_dir = Path::new(&manifest_dir).join("extensions");
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated_extensions.rs");

    let mut expand_entries = Vec::new();
    let mut bin_entries = Vec::new();
    let mut root_entries = Vec::new();
    let mut admin_entries = Vec::new();

    if extensions_dir.exists() {
        for entry in fs::read_dir(&extensions_dir)? {
            let entry = entry?;
            let path = entry.path();
            if path.is_file() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.ends_with(".expand.rs") {
                        let stem = &name[..name.len() - ".expand.rs".len()];
                        let ident = sanitize_ident(stem);
                        expand_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".bin.rs") {
                        let stem = &name[..name.len() - ".bin.rs".len()];
                        let ident = sanitize_ident(stem);
                        bin_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".root.rs") {
                        let stem = &name[..name.len() - ".root.rs".len()];
                        let ident = sanitize_ident(stem);
                        root_entries.push((ident, name.to_string()));
                    } else if name.ends_with(".admin.rs") {
                        let stem = &name[..name.len() - ".admin.rs".len()];
                        let ident = sanitize_ident(stem);
                        admin_entries.push((ident, name.to_string()));
                    }
                }
            }
        }
    }

    expand_entries.sort_by(|a, b| a.0.cmp(&b.0));
    bin_entries.sort_by(|a, b| a.0.cmp(&b.0));
    root_entries.sort_by(|a, b| a.0.cmp(&b.0));
    admin_entries.sort_by(|a, b| a.0.cmp(&b.0));

    let mut out = String::new();
    out.push_str("// Auto-generated by build.rs. Do not edit.\n\n");

    // Generate expand extensions
    for (ident, filename) in expand_entries {
        out.push_str(&format!(
            "mod {ident} {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate bin extensions
    for (ident, filename) in bin_entries {
        out.push_str(&format!(
            "mod {ident}_bin {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate root extensions
    for (ident, filename) in root_entries {
        out.push_str(&format!(
            "mod {ident}_root {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate admin extensions
    for (ident, filename) in &admin_entries {
        out.push_str(&format!(
            "mod {ident}_admin {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/extensions/{file}\"));\n}}\n\n",
            ident = ident,
            file = filename
        ));
    }

    // Generate ExtensionRegistry
    out.push_str("pub struct ExtensionRegistry {\n");
    out.push_str("    admin_keys: std::collections::HashMap<String, String>,\n");
    out.push_str("}\n\n");

    out.push_str("impl ExtensionRegistry {\n");
    out.push_str("    pub fn new() -> Self {\n");
    out.push_str("        let mut registry = Self {\n");
    out.push_str("            admin_keys: std::collections::HashMap::new(),\n");
    out.push_str("        };\n");
    out.push_str("        // Load admin keys on initialization\n");
    out.push_str("        let _ = registry.load_existing_admin_keys();\n");
    out.push_str("        let _ = registry.generate_missing_admin_keys();\n");
    out.push_str("        registry\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn process_html(&self, html: &str, url: &str) -> String {\n");
    out.push_str("        // Process HTML with extensions\n");
    out.push_str("        let mut result = html.to_string();\n");
    out.push_str("        \n");
    
    // Dynamically generate extension processing for each .expand.rs file
    let extensions_dir = std::path::Path::new("extensions");
    if let Ok(entries) = std::fs::read_dir(extensions_dir) {
        for entry in entries.flatten() {
            if let Some(file_name) = entry.file_name().to_str() {
                if file_name.ends_with(".expand.rs") {
                    let ext_name = file_name.replace(".expand.rs", "");
                    out.push_str(&format!(
                        "        // Process #EXTEND:{}() directives\n",
                        ext_name
                    ));
                    out.push_str(&format!(
                        "        // Process #EXTEND:{}() directives using simple string operations\n",
                        ext_name
                    ));
                    out.push_str(&format!(
                        "        while let Some(start) = result.find(\"#EXTEND:{}(\") {{\n",
                        ext_name
                    ));
                    out.push_str(&format!(
                        "            let end = result[start..].find(')').unwrap_or(0) + start + 1;\n"
                    ));
                    out.push_str(&format!(
                        "            let args_start = start + \"#EXTEND:{}(\".len();\n",
                        ext_name
                    ));
                    out.push_str(&format!(
                        "            let args = &result[args_start..end-1];\n"
                    ));
                    out.push_str(&format!(
                        "            let replacement = {}::extend(url, args);\n",
                        ext_name
                    ));
                    out.push_str(&format!(
                        "            result.replace_range(start..end, &replacement);\n"
                    ));
                    out.push_str("        }\n");
                    out.push_str("        \n");
                }
            }
        }
    }
    
    out.push_str("        result\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn is_valid_admin_key(&self, key: &str) -> bool {\n");
    out.push_str("        self.admin_keys.values().any(|k| k == key)\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn process_admin_request(&self, path: &str, method: &str, query: &str, body: &str, headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Process admin request by checking for admin extensions\n");
    out.push_str("        for (ext_name, key) in &self.admin_keys {\n");
    out.push_str("            let admin_prefix = format!(\"/{}_\", ext_name);\n");
    out.push_str("            println!(\"DEBUG: Checking prefix {} with key {}\", admin_prefix, key);\n");
    out.push_str("            if path.starts_with(&admin_prefix) {\n");
    out.push_str("                match ext_name.as_str() {\n");
    out.push_str("                    \"comment\" => {\n");
    out.push_str("                        return comment_admin::handle_comment_admin_request(path, method, query, body, headers, &self.admin_keys)\n");
    out.push_str("                            .map_err(|e| Box::new(std::io::Error::new(std::io::ErrorKind::Other, e)) as Box<dyn std::error::Error + Send + Sync>);\n");
    out.push_str("                    }\n");
    out.push_str("                    _ => continue,\n");
    out.push_str("                }\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("        Ok(r#\"{\\\"error\\\": \\\"Admin path not found\\\"}\"#.to_string())\n");
    out.push_str("    }\n\n");

    // Add missing methods that the main code expects
    out.push_str("    pub fn load_existing_admin_keys(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Load existing admin keys from file system\n");
    out.push_str("        let admin_keys_file = std::path::Path::new(\"/var/lib/easypeas/admin_keys\");\n");
    out.push_str("        if admin_keys_file.exists() {\n");
    out.push_str("            if let Ok(content) = std::fs::read_to_string(admin_keys_file) {\n");
    out.push_str("                for line in content.lines() {\n");
    out.push_str("                    if let Some((key, value)) = line.split_once('_') {\n");
    out.push_str("                        self.admin_keys.insert(key.to_string(), value.to_string());\n");
    out.push_str("                    }\n");
    out.push_str("                }\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("        Ok(())\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn generate_missing_admin_keys(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Only generate keys for extensions that don't already exist\n");
    out.push_str("        // This ensures stored keys are always preserved\n");
    out.push_str("        let admin_extensions = vec![\"comment\"];\n");
    out.push_str("        let mut needs_save = false;\n");
    out.push_str("        \n");
    out.push_str("        for ext in admin_extensions {\n");
    out.push_str("            if !self.admin_keys.contains_key(ext) {\n");
    out.push_str("                use std::collections::hash_map::DefaultHasher;\n");
    out.push_str("                use std::hash::{Hash, Hasher};\n");
    out.push_str("                let mut hasher = DefaultHasher::new();\n");
    out.push_str("                std::time::SystemTime::now().hash(&mut hasher);\n");
    out.push_str("                ext.hash(&mut hasher);\n");
    out.push_str("                let key = format!(\"{:016x}\", hasher.finish());\n");
    out.push_str("                self.admin_keys.insert(ext.to_string(), key);\n");
    out.push_str("                needs_save = true;\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("        \n");
    out.push_str("        if needs_save {\n");
    out.push_str("            let admin_keys_file = std::path::Path::new(\"/var/lib/easypeas/admin_keys\");\n");
    out.push_str("            if let Some(parent) = admin_keys_file.parent() {\n");
    out.push_str("                let _ = std::fs::create_dir_all(parent);\n");
    out.push_str("            }\n");
    out.push_str("            let mut content = String::new();\n");
    out.push_str("            for (k, v) in &self.admin_keys {\n");
    out.push_str("                content.push_str(&format!(\"{}_{}\\n\", k, v));\n");
    out.push_str("            }\n");
    out.push_str("            let _ = std::fs::write(admin_keys_file, content);\n");
    out.push_str("        }\n");
    out.push_str("        Ok(())\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn ensure_admin_file_permissions(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Ensure admin file permissions\n");
    out.push_str("        Ok(())\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn initialize_root_extensions(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Initialize root extensions\n");
    out.push_str("        Ok(())\n");
    out.push_str("    }\n\n");

    out.push_str("    pub fn handle_bin_request(&self, bin_path: &str, method: &str, query_string: &str, headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {\n");
    out.push_str("        // Handle bin request\n");
    out.push_str("        match bin_path {\n");
    out.push_str("            \"/cgi-bin/comment\" => {\n");
    out.push_str("                comment_bin::handle_comment_request(method, bin_path, \"localhost\", query_string, headers)\n");
    out.push_str("                    .map_err(|e| Box::new(std::io::Error::new(std::io::ErrorKind::Other, e)) as Box<dyn std::error::Error + Send + Sync>)\n");
    out.push_str("            }\n");
    out.push_str("            _ => {\n");
    out.push_str("                Err(Box::new(std::io::Error::new(std::io::ErrorKind::NotFound, \"Bin extension not found\")) as Box<dyn std::error::Error + Send + Sync>)\n");
    out.push_str("            }\n");
    out.push_str("        }\n");
    out.push_str("    }\n");
    out.push_str("}\n");

    fs::write(&dest_path, out)?;
    println!("cargo:rerun-if-changed=extensions");
    Ok(())
}
