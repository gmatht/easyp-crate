//! easyp - On-demand HTTPS server with ACME certificate management
//!
//! This example demonstrates a complete on-demand HTTPS server that:
//! - Accepts HTTPS connections using rustls Acceptor
//! - Validates that domains resolve to authorized IP addresses
//! - Dynamically fetches ACME certificates from Let's Encrypt
//! - Caches certificates for performance
//! - Handles both HTTP-01 and DNS-01 challenges
//!
//! Usage:
//!   cargo run --example easyp --features acme -- --help

use std::collections::{BTreeMap, HashMap};
use std::io::{Read, Write};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::time::Duration;

use lexopt::prelude::*;
use rustls::server::{Acceptor, ResolvesServerCert};
use rustls::{ServerConfig, ServerConnection};
use rustls::sign::CertifiedKey;

// Simple logger without regex dependency
struct SimpleLogger;

impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.level() <= log::max_level()
    }

    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            println!("{}: {}", record.level(), record.args());
        }
    }

    fn flush(&self) {}
}

#[cfg(feature = "acme")]
use rustls_acme::{AcmeClient, OnDemandCertResolver, DnsValidator};
use rustls_acme::{AcmeConfig, ChallengeType};

// Import our modules
#[path = "../cgi_env.rs"]
mod cgi_env;
#[path = "../modules/secure_file_server_module.rs"]
mod secure_file_server_module;
use secure_file_server_module::{SecureFileServer, SecurityConfig};

#[path = "../modules/file_handler.rs"]
mod file_handler;
use file_handler::{
    extract_domain_from_host_header
};

// HTTP Multi-Version Support modules
#[path = "../modules/http_version.rs"]
mod http_version;
#[path = "../modules/http_response.rs"]
mod http_response;
#[path = "../modules/connection_policy.rs"]
mod connection_policy;

use http_version::HttpVersion;
use http_response::HttpResponse;
use connection_policy::ConnectionPolicy;

// Extension system - auto-generated by build.rs
#[cfg(feature = "extensions")]
include!(concat!(env!("OUT_DIR"), "/generated_extensions.rs"));

// Debug: Check if extensions feature is enabled
#[cfg(feature = "extensions")]
fn debug_extensions_enabled() {
    println!("DEBUG: Extensions feature is ENABLED");
}

#[cfg(not(feature = "extensions"))]
fn debug_extensions_enabled() {
    println!("DEBUG: Extensions feature is DISABLED");
}

// Always define ExtensionRegistry - either from generated code or as placeholder
#[cfg(not(feature = "extensions"))]
#[derive(Clone)]
struct ExtensionRegistry;

#[cfg(not(feature = "extensions"))]
impl ExtensionRegistry {
    fn new() -> Self {
        Self
    }

    fn process_html(&self, html: &str, _url: &str) -> String {
        html.to_string()
    }

    fn is_valid_admin_key(&self, _key: &str) -> bool {
        false
    }

    async fn process_admin_request(&self, _path: &str, _query: &str, _body: &str, _headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error>> {
        Ok(r#"{"error": "Admin features not available"}"#.to_string())
    }
}

#[derive(Clone)]
struct Args {
    domains: Vec<String>,
    http_port: u16,
    https_port: u16,
    email: Option<String>,
    staging: bool,
    over_9000: bool,
    test_client: Option<String>,
    test_root: String,
    root: String,
    allowed_ips: Option<String>,
    cache_dir: String,
    verbose: bool,
    test_mode: bool,
    restore_backup: bool,
    bogus_domain: Option<String>,
    port: u16,
    acme_directory: String,
    acme_email: Option<String>,
    challenge_type: String,
    admin_urls: bool,
}

impl Args {
    fn parse() -> Result<Self, Box<dyn std::error::Error>> {
        let mut domains = Vec::new();
        let mut http_port = 80;
        let mut https_port = 443;
        let mut email = None;
        let mut staging = false;
        let mut over_9000 = false;
        let mut test_client = None;
        let mut test_root = "test_root".to_string();
        let mut root = "/var/www/html".to_string();
        let mut allowed_ips = None;
        let mut cache_dir = "/var/lib/easyp/certs".to_string();
        let mut verbose = false;
        let mut test_mode = false;
        let mut restore_backup = false;
        let mut bogus_domain = None;
        let mut port = 443;
        let mut acme_directory = "https://acme-v02.api.letsencrypt.org/directory".to_string();
        let mut acme_email = None;
        let mut challenge_type = "http01".to_string();
        let mut admin_urls = false;

        let mut parser = lexopt::Parser::from_env();
        while let Some(arg) = parser.next()? {
            match arg {
                Value(val) => {
                    domains.push(val.to_string_lossy().to_string());
                }
                Short('p') | Long("port") => {
                    port = parser.value()?.parse()?;
                }
                Long("http-port") => {
                    http_port = parser.value()?.parse()?;
                }
                Long("https-port") => {
                    https_port = parser.value()?.parse()?;
                }
                Long("email") => {
                    email = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("staging") => {
                    staging = true;
                }
                Long("over-9000") => {
                    over_9000 = true;
                }
                Long("test-client") => {
                    test_client = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("test-root") => {
                    test_root = parser.value()?.to_string_lossy().to_string();
                }
                Long("root") => {
                    root = parser.value()?.to_string_lossy().to_string();
                }
                Long("allowed-ips") => {
                    allowed_ips = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("cache-dir") => {
                    cache_dir = parser.value()?.to_string_lossy().to_string();
                }
                Short('v') | Long("verbose") => {
                    verbose = true;
                }
                Long("test-mode") => {
                    test_mode = true;
                }
                Long("restore-backup") => {
                    restore_backup = true;
                }
                Long("bogus-domain") => {
                    bogus_domain = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("acme-directory") => {
                    acme_directory = parser.value()?.to_string_lossy().to_string();
                }
                Long("acme-email") => {
                    acme_email = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("challenge-type") => {
                    challenge_type = parser.value()?.to_string_lossy().to_string();
                }
                Long("admin-urls") => {
                    admin_urls = true;
                }
                Long("help") => {
                    println!("easyp - On-demand HTTPS server with ACME certificate management");
                    println!();
                    println!("USAGE:");
                    println!("    easyp [OPTIONS] [DOMAINS]...");
                    println!();
                    println!("ARGS:");
                    println!("    [DOMAINS]...    Optional domains to serve (e.g., example.com, *.example.com)");
                    println!("                   If not specified, domains will be discovered on-demand from certificate requests");
                    println!();
                    println!("OPTIONS:");
                    println!("    -p, --port <PORT>                    Port to listen on (legacy, use --https-port instead) [default: 443]");
                    println!("        --http-port <PORT>               HTTP port [default: 80]");
                    println!("        --https-port <PORT>              HTTPS port [default: 443]");
                    println!("        --email <EMAIL>                  Email for ACME certificate registration");
                    println!("        --staging                         Use Let's Encrypt staging environment");
                    println!("        --over-9000                       Add 9000 to default port numbers (HTTP: 9080, HTTPS: 9443)");
                    println!("        --test-client <CLIENT>            Test client binary to run when server is ready");
                    println!("        --test-root <ROOT>                Test root directory for integration tests [default: test_root]");
                    println!("        --root <ROOT>                     Document root directory [default: /var/www/html]");
                    println!("        --allowed-ips <IPS>               Allowed IP addresses for on-demand certificate requests (comma-separated)");
                    println!("        --cache-dir <DIR>                 Cache directory for ACME certificates [default: /var/lib/easyp/certs]");
                    println!("    -v, --verbose                        Enable verbose logging");
                    println!("        --test-mode                       Test mode (use self-signed certificates)");
                    println!("        --restore-backup                  Restore ACME certificates from backup before starting");
                    println!("        --bogus-domain <DOMAIN>           Bogus domain to use for ACME requests (workaround for rate limits)");
                    println!("        --acme-directory <URL>            ACME directory URL (legacy, use --staging instead) [default: https://acme-v02.api.letsencrypt.org/directory]");
                    println!("        --acme-email <EMAIL>              Email address for ACME account (legacy, use --email instead)");
                    println!("        --challenge-type <TYPE>           Challenge type (http01 or dns01) [default: http01]");
                    println!("        --admin-urls                      Print admin URLs for all domains and admin keys, then exit");
                    println!("        --help                            Print help information");
                    std::process::exit(0);
                }
                _ => return Err(format!("unexpected argument: {:?}", arg).into()),
            }
        }

        // Domains are optional for on-demand HTTPS server
        // The server can discover domains dynamically from certificate requests

        Ok(Args {
            domains,
            http_port,
            https_port,
            email,
            staging,
            over_9000,
            test_client,
            test_root,
            root,
            allowed_ips,
            cache_dir,
            verbose,
            test_mode,
            restore_backup,
            bogus_domain,
            port,
            acme_directory,
            acme_email,
            challenge_type,
            admin_urls,
        })
    }
}

/// Test certificate resolver that loads or creates a self-signed certificate on startup
/// and never creates new certificates after that
#[derive(Debug)]
struct TestCertResolver {
    allowed_ips: Vec<IpAddr>,
    cert_cache: Arc<Mutex<HashMap<String, CertifiedKey>>>,
    default_cert: Option<CertifiedKey>,
}

impl TestCertResolver {
    fn new(allowed_ips: Vec<IpAddr>) -> Result<Self, Box<dyn std::error::Error>> {
        println!("üîç Initializing TestCertResolver with self-signed certificate...");

        // Try to load existing self-signed certificate
        let cert_path = "/var/lib/easyp/certs/localhost/fullchain.pem";
        let key_path = "/var/lib/easyp/certs/localhost/privkey.pem";

        let default_cert = if std::path::Path::new(cert_path).exists() && std::path::Path::new(key_path).exists() {
            println!("üîç Loading existing self-signed certificate from {}", cert_path);
            match Self::load_certificate_from_files(cert_path, key_path) {
                Ok(cert) => {
                    println!("‚úÖ Successfully loaded existing self-signed certificate");
                    Some(cert)
                }
                Err(e) => {
                    println!("‚ö†Ô∏è  Failed to load existing certificate: {}, will create new one", e);
                    None
                }
            }
        } else {
            println!("üîç No existing certificate found, creating new self-signed certificate...");
            None
        };

        let default_cert = match default_cert {
            Some(cert) => Some(cert),
            None => {
                println!("üîç Generating new self-signed certificate for localhost...");
                match Self::generate_self_signed_certificate("localhost") {
                    Ok(cert) => {
                        println!("‚úÖ Successfully generated new self-signed certificate");
                        Some(cert)
                    }
                    Err(e) => {
                        println!("‚ùå Failed to generate self-signed certificate: {}", e);
                        return Err(e);
                    }
                }
            }
        };

        Ok(Self {
            allowed_ips,
            cert_cache: Arc::new(Mutex::new(HashMap::new())),
            default_cert,
        })
    }

    fn load_certificate_from_files(cert_path: &str, key_path: &str) -> Result<CertifiedKey, Box<dyn std::error::Error>> {
        use rustls_pemfile::{certs, pkcs8_private_keys};
        use std::io::BufReader;

        let cert_file = std::fs::File::open(cert_path)?;
        let mut cert_reader = BufReader::new(cert_file);
        let cert_chain: Result<Vec<_>, _> = certs(&mut cert_reader)
            .into_iter()
            .map(|cert| cert.map(rustls::pki_types::CertificateDer::from))
            .collect();
        let cert_chain = cert_chain?;

        let key_file = std::fs::File::open(key_path)?;
        let mut key_reader = BufReader::new(key_file);
        let keys: Result<Vec<_>, _> = pkcs8_private_keys(&mut key_reader).collect();
        let mut keys = keys?;

        if keys.is_empty() {
            return Err("No private key found in key file".into());
        }

        let key = rustls::pki_types::PrivateKeyDer::Pkcs8(
            rustls::pki_types::PrivatePkcs8KeyDer::from(keys.remove(0))
        );

        // Create the CertifiedKey using the correct API
        let certified_key = rustls::sign::CertifiedKey::from_der(
            cert_chain.into(),
            key,
            &rustls::crypto::ring::default_provider(),
        ).map_err(|e| format!("Failed to create CertifiedKey: {}", e))?;

        Ok(certified_key)
    }

    fn generate_self_signed_certificate(domain: &str) -> Result<CertifiedKey, Box<dyn std::error::Error>> {
        use rcgen::{CertificateParams, KeyPair, SanType, PKCS_RSA_SHA256};

        // Create certificate directory
        let cert_dir = format!("/var/lib/easyp/certs/{}", domain);
        std::fs::create_dir_all(&cert_dir)?;

        // Generate RSA key pair for better Safari 6-8 compatibility
        // Safari 6-8 has better support for RSA certificates than ECDSA
        let key_pair = KeyPair::generate_for(&PKCS_RSA_SHA256)?;

        // Create certificate parameters
        let mut params = CertificateParams::new(vec![domain.to_string()])?;

        // Add Subject Alternative Names for better compatibility
        params.subject_alt_names = vec![
            SanType::DnsName(rcgen::string::Ia5String::try_from(domain)?),
            SanType::DnsName(rcgen::string::Ia5String::try_from("localhost")?),
            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),
            SanType::IpAddress(std::net::IpAddr::V6(std::net::Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1))),
        ];

        // Set additional parameters for Safari compatibility
        params.distinguished_name = rcgen::DistinguishedName::new();

        // Use SHA-256 signature algorithm for better Safari 6-8 compatibility
        // Safari 6-8 may not support SHA-384 or SHA-512 signatures
        // The algorithm is set when creating the KeyPair, not in params

        // Set key usage for TLS server authentication
        params.key_usages = vec![
            rcgen::KeyUsagePurpose::DigitalSignature,
            rcgen::KeyUsagePurpose::KeyEncipherment,
        ];

        // Set extended key usage for TLS server authentication
        params.extended_key_usages = vec![
            rcgen::ExtendedKeyUsagePurpose::ServerAuth,
        ];

        // Generate the certificate
        let cert = params.self_signed(&key_pair)?;

        // Get PEM-encoded certificate and private key
        let cert_pem = cert.pem();
        let key_pem = key_pair.serialize_pem();

        // Write fullchain.pem (same as cert.pem for self-signed)
        std::fs::write(format!("{}/fullchain.pem", cert_dir), &cert_pem)?;

        // Write privkey.pem
        std::fs::write(format!("{}/privkey.pem", cert_dir), &key_pem)?;

        // Set proper permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&cert_dir)?.permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&cert_dir, perms)?;

            let mut key_perms = std::fs::metadata(format!("{}/privkey.pem", cert_dir))?.permissions();
            key_perms.set_mode(0o600);
            std::fs::set_permissions(format!("{}/privkey.pem", cert_dir), key_perms)?;
        }

        println!("‚úÖ Self-signed certificate generated for {} in {}", domain, cert_dir);

        // Convert to CertifiedKey format
        let cert_der = cert.der().to_vec();
        let key_der = key_pair.serialize_der();

        let cert_chain = vec![rustls::pki_types::CertificateDer::from(cert_der)];
        let key = rustls::pki_types::PrivateKeyDer::Pkcs8(
            rustls::pki_types::PrivatePkcs8KeyDer::from(key_der)
        );

        // Create the CertifiedKey using the correct API
        let certified_key = rustls::sign::CertifiedKey::from_der(
            cert_chain.into(),
            key,
            &rustls::crypto::ring::default_provider(),
        ).map_err(|e| format!("Failed to create CertifiedKey: {}", e))?;

        Ok(certified_key)
    }
}

impl ResolvesServerCert for TestCertResolver {
    fn resolve(&self, client_hello: &rustls::server::ClientHello<'_>) -> Result<rustls::sign::CertifiedSigner, rustls::Error> {
        let Some(server_name) = client_hello.server_name() else {
            // If no server name, use the default certificate
            if let Some(ref default_cert) = self.default_cert {
                return default_cert.signer(client_hello.signature_schemes())
                    .ok_or(rustls::Error::NoSuitableCertificate);
            }
            return Err(rustls::Error::NoSuitableCertificate);
        };

        let domain = server_name.as_ref();

        // Check cache first
        if let Ok(cache) = self.cert_cache.lock() {
            if let Some(certified_key) = cache.get(domain) {
                return certified_key.signer(client_hello.signature_schemes())
                    .ok_or(rustls::Error::NoSuitableCertificate);
            }
        }

        // For any domain, return the default self-signed certificate
        // This ensures we never create new certificates after startup
        if let Some(ref default_cert) = self.default_cert {
            // Just return the signer directly - no need to cache since we only have one cert
            return default_cert.signer(client_hello.signature_schemes())
                .ok_or(rustls::Error::NoSuitableCertificate);
        }

        println!("‚ùå No default certificate available for domain: {}", domain);
        Err(rustls::Error::NoSuitableCertificate)
    }
}

/// On-demand HTTPS server
struct OnDemandHttpsServer {
    http_listener: tokio::net::TcpListener,  // Port 80 for ACME challenges
    https_listener: tokio::net::TcpListener, // Port 443 for HTTPS traffic
    cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
    args: Args,
    http_challenges: Arc<Mutex<BTreeMap<String, String>>>, // token -> key_authorization
    #[cfg(feature = "acme")]
    acme_client: Option<Arc<AcmeClient>>, // Added for challenge storage
    allowed_ips: Vec<IpAddr>, // Store allowed IPs for display
    extension_registry: Arc<Mutex<ExtensionRegistry>>, // Extension system
    secure_file_server: SecureFileServer, // Secure file serving with security features
}

impl OnDemandHttpsServer {
    /// Create a new on-demand HTTPS server
    async fn new(args: Args) -> Result<Self, Box<dyn std::error::Error>> {
        // Apply --over-9000 option to port numbers
        let http_port = if args.over_9000 {
            args.http_port + 9000
        } else {
            args.http_port
        };

        let https_port = if args.over_9000 {
            args.https_port + 9000
        } else {
            args.https_port
        };

        // Use legacy --port argument if provided (overrides --https-port)
        let final_https_port = if args.port != 443 || args.over_9000 {
            args.port
        } else {
            https_port
        };

        // Create HTTP listener on specified port for ACME challenges
        let http_listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", http_port)).await?;

        // Create HTTPS listener on specified port for HTTPS traffic
        let https_listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", final_https_port)).await?;

        // Look up www-data UID/GID dynamically (only on UNIX systems)
        #[cfg(unix)]
        let (www_data_uid, www_data_gid) = get_www_data_uid_gid()?;

        // Create secure file server with security features
        let document_root = if args.root.starts_with('/') {
            // Absolute path
            PathBuf::from(&args.root)
        } else {
            // Relative path - make it absolute
            std::env::current_dir()?.join(&args.root)
        };

        let secure_file_server = SecureFileServer::new(SecurityConfig {
            document_root,
            follow_symlinks: false, // Security: don't follow symlinks by default
            max_file_size: 10 * 1024 * 1024 * 1024 * 1024, // 10TB max file size
            allowed_extensions: vec![
/*
                // Web files
                "html".to_string(), "htm".to_string(), "css".to_string(),
                "js".to_string(), "json".to_string(),
                // Images
                "jpg".to_string(), "jpeg".to_string(), "png".to_string(),
                "gif".to_string(), "svg".to_string(), "webp".to_string(),
                "ico".to_string(),
                // WebAssembly
                "wasm".to_string(),
                // Documents
                "txt".to_string(), "pdf".to_string(),
                // Archives
                "zip".to_string(), "tar".to_string(), "gz".to_string(),
*/
            ],
            blocked_extensions: vec![
/*
                // Dangerous executables
                "exe".to_string(), "bat".to_string(), "cmd".to_string(),
                "com".to_string(), "pif".to_string(), "scr".to_string(),
                "vbs".to_string(), "jar".to_string(), "sh".to_string(),
*/
                // System files
                "htaccess".to_string(), "htpasswd".to_string(),
            ],
            #[cfg(unix)]
            drop_to_uid: Some(www_data_uid),
            #[cfg(unix)]
            drop_to_gid: Some(www_data_gid),
            #[cfg(not(unix))]
            drop_to_uid: None,
            #[cfg(not(unix))]
            drop_to_gid: None,
            keep_alive_timeout: Duration::from_secs(5),
            keep_alive_max_requests: 100,
            minimum_http_version: HttpVersion::Http09,
        });

               #[cfg(target_os = "redox")]
               let allowed_ips = Vec::new(); //STUB
               // Parse allowed IP addresses or auto-detect
               #[cfg(not(target_os = "redox"))]
               let allowed_ips = if let Some(ips_str) = &args.allowed_ips {
                   parse_allowed_ips(ips_str)?
               } else {
                   println!("[{}] No allowed IPs specified, auto-detecting server IPs...",
                 std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
                   let detected_ips = detect_server_ips().unwrap_or_else(|e| {
                       println!("Warning: Could not detect server IPs ({}), returning empty list", e);
                       Vec::new()
                   });

                   if detected_ips.is_empty() {
                       eprintln!("Error: No valid IP addresses detected. Please specify --allowed-ips explicitly.");
                       eprintln!("This is required for security - localhost addresses are not allowed for ACME requests.");
                       std::process::exit(1);
                   }

                   detected_ips
               };

               // Create certificate resolver with real ACME integration
               #[cfg(feature = "acme")]
               let (cert_resolver, acme_client) = if args.test_mode {
                   // In test mode, use staging ACME servers for real certificates
                   let directory_url = "https://acme-staging-v02.api.letsencrypt.org/directory".to_string();

                   // Determine email (prefer new --email over legacy --acme-email)
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (use staging subdirectory for test mode)
                   let cache_dir = Some(format!("{}/staging", args.cache_dir));

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir,
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01("".to_string(), "".to_string()),
                       is_staging: true, // Always staging in test mode
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);
                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               } else {
                   // Determine ACME directory URL
                   let directory_url = if args.staging {
                       "https://acme-staging-v02.api.letsencrypt.org/directory".to_string()
                   } else {
                       args.acme_directory.clone()
                   };

                   // Determine email (prefer new --email over legacy --acme-email)
                   // If no email is provided, the ACME client will generate webmaster@domain for each domain
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (use staging or production subdirectory based on staging flag)
                   let cache_dir = if args.staging || args.acme_directory.contains("staging") || args.acme_directory.contains("stg") {
                       Some(format!("{}/staging", args.cache_dir))
                   } else {
                       Some(format!("{}/production", args.cache_dir))
                   };

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir: cache_dir.clone(),
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01("".to_string(), "".to_string()),
                       is_staging: args.staging || args.acme_directory.contains("staging") || args.acme_directory.contains("stg"),
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);

                   // Restore from backup if requested
                   if args.restore_backup {
                       println!("üîÑ Restoring ACME certificates from backup...");
                       let acme_persist_dir = format!("{}/acme_lib", cache_dir.as_ref().unwrap());
                       if let Err(e) = acme_client.restore_acme_data(&acme_persist_dir) {
                           println!("‚ö†Ô∏è  Failed to restore from backup: {}", e);
                       } else {
                           println!("‚úÖ ACME certificates restored from backup");
                       }
                   }

                   // Note: ACME account will be initialized per-domain when certificates are requested

                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               };

               #[cfg(not(feature = "acme"))]
               let (cert_resolver, acme_client) = {
                   // Fallback to test resolver if ACME feature not enabled
                   (Arc::new(TestCertResolver::new(allowed_ips)?), None)
               };

               // Ensure certificate cache directory has proper ownership before dropping privileges
               #[cfg(unix)]
               if let Err(e) = ensure_cert_cache_permissions(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set certificate cache permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }

               // Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
               #[cfg(unix)]
               if let Err(e) = ensure_tmp_acme_permissions(www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set /tmp/acme_certs permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }

               // Ensure ACME cache directory is properly configured and accessible
               println!("ACME cache directory: {}", args.cache_dir);
               #[cfg(unix)]
               if let Err(e) = ensure_acme_cache_directory(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Error: Failed to set up ACME cache directory: {}", e);
                   return Err(format!("ACME cache directory setup failed: {}", e).into());
               }

               // Domain request logger removed - was unused dead code

                // Initialize root extensions and admin system before dropping privileges
                #[cfg(feature = "extensions")]
                let extension_registry = {
                    println!("Initializing root extensions and admin system...");
                    let mut registry = ExtensionRegistry::new();

                    // Load existing admin keys from file
                    if let Err(e) = registry.load_existing_admin_keys() {
                        println!("Warning: Failed to load existing admin keys: {}", e);
                    }

                    // Generate missing admin keys and append to file
                    if let Err(e) = registry.generate_missing_admin_keys() {
                        println!("Warning: Failed to generate missing admin keys: {}", e);
                    }

                    // Ensure admin file has correct permissions
                    if let Err(e) = registry.ensure_admin_file_permissions() {
                        println!("Warning: Failed to set admin file permissions: {}", e);
                    }

                    // Initialize root extensions
                    if let Err(e) = registry.initialize_root_extensions() {
                        println!("Warning: Failed to initialize root extensions: {}", e);
                    }

                    Arc::new(Mutex::new(registry))
                };

                #[cfg(not(feature = "extensions"))]
                let extension_registry = Arc::new(Mutex::new(ExtensionRegistry::new()));

               // Drop privileges to unprivileged user after binding to privileged ports
               if let Err(e) = secure_file_server.drop_privileges() {
                   println!("Warning: Failed to drop privileges: {}", e);
                   // Continue anyway - this is not a fatal error
               } else {
                   // Verify that privileges were dropped successfully
                   match std::process::Command::new("whoami").output() {
                       Ok(output) => {
                           if output.status.success() {
                               let username = String::from_utf8_lossy(&output.stdout).trim().to_string();
                               println!("Server now running as user: {}", username);
                           } else {
                               println!("Warning: Could not determine current user after privilege drop");
                           }
                       }
                       Err(_) => {
                           println!("Warning: Could not determine current user after privilege drop");
                       }
                   }
               }


               // Use shared challenge storage from ACME client instead of separate storage
               let http_challenges = if let Some(ref acme_client) = acme_client {
                   // Convert the ACME client's challenge storage to the format expected by HTTP server
                   Arc::new(Mutex::new(BTreeMap::new())) // We'll access challenges directly from ACME client
               } else {
                   Arc::new(Mutex::new(BTreeMap::new()))
               };

               Ok(Self {
                   http_listener,
                   https_listener,
                   cert_resolver,
                   args,
                   http_challenges,
                   acme_client,
                   allowed_ips,
                   extension_registry,
                   secure_file_server,
               })
    }

    /// Run the server
    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Calculate actual ports (including --over-9000 effect)
        let http_port = if self.args.over_9000 {
            self.args.http_port + 9000
        } else {
            self.args.http_port
        };

        let https_port = if self.args.over_9000 {
            self.args.https_port + 9000
        } else {
            self.args.https_port
        };

        let final_https_port = if self.args.port != 443 || self.args.over_9000 {
            self.args.port
        } else {
            https_port
        };

        println!("Starting easyp on-demand HTTPS server");
        println!("HTTP listener on port {} (for ACME challenges)", http_port);
        println!("HTTPS listener on port {} (for HTTPS traffic)", final_https_port);
        println!("Allowed IPs: {:?}", self.allowed_ips);
        println!("ACME Directory: {}", if self.args.staging { "https://acme-staging-v02.api.letsencrypt.org/directory" } else { &self.args.acme_directory });
        println!("Challenge Type: {}", self.args.challenge_type);
        println!("Test Mode: {}", self.args.test_mode);
        if !self.args.domains.is_empty() {
            println!("Domains: {:?}", self.args.domains);
        }
        if let Some(ref email) = self.args.email.clone().or(self.args.acme_email.clone()) {
            println!("Email: {}", email);
        }
        println!("Document Root: {}", self.args.root);
        println!("Cache Directory: {}", self.args.cache_dir);

        // Run test client if specified
        if let Some(ref test_client) = self.args.test_client {
            let test_client = test_client.clone();
            println!("Running test client: {}", test_client);
            std::thread::spawn(move || {
                let output = std::process::Command::new(&test_client)
                    .output()
                    .expect("Failed to execute test client");
                println!("Test client output: {}", String::from_utf8_lossy(&output.stdout));
                if !output.stderr.is_empty() {
                    eprintln!("Test client stderr: {}", String::from_utf8_lossy(&output.stderr));
                }
            });
        }

        let mut connections: Vec<ServerConnection> = Vec::new();

        println!("üîç Starting async server loop");

        // No more polling! The ACME client and HTTP server now share the same challenge storage
        // Challenges are automatically available to the HTTP server when created by the ACME client

        println!("üîç Starting main server loop - listening on HTTP port {} and HTTPS port {}", http_port, final_https_port);
        loop {
        tokio::select! {
                // Accept HTTP connections (port 80) for ACME challenges
                result = self.http_listener.accept() => {
                    match result {
                        Ok((stream, addr)) => {
                            println!("üîç New HTTP connection from {} (ACME challenge)", addr);

                            // Handle HTTP connection for ACME challenges and file serving
                            let acme_client = self.acme_client.clone();
                            let http_challenges = self.http_challenges.clone();
                            let secure_file_server = self.secure_file_server.clone();
                            let extension_registry = self.extension_registry.clone();

                    tokio::task::spawn_blocking(move || {
                        let rt = tokio::runtime::Handle::current();
                        rt.block_on(async {
                            match Self::handle_http_connection(stream, acme_client, http_challenges, secure_file_server, extension_registry).await {
                                Ok(()) => {},
                                Err(e) => {
                                    let error_msg = format!("{}", e);
                                    eprintln!("HTTP connection error: {}", error_msg);
                                }
                            }
                        })
                    });
                        }
                        Err(e) => {
                            eprintln!("‚ùå HTTP accept error: {}", e);
                        }
                    }
                }

                // Accept HTTPS connections (port 443) for HTTPS traffic
                result = self.https_listener.accept() => {
                    println!("üîç HTTPS accept() returned: {:?}", result);
                    match result {
                        Ok((stream, addr)) => {
                            println!("üîç New HTTPS connection from {}", addr);

                            // Handle HTTPS connection
                            let cert_resolver = self.cert_resolver.clone();
                            let args = self.args.clone();
                            let acme_client = self.acme_client.clone();
                            let http_challenges = self.http_challenges.clone();
                            let extension_registry = self.extension_registry.clone();
                            let secure_file_server = self.secure_file_server.clone();

                            tokio::spawn(async move {
                                if let Err(e) = Self::handle_connection_static(stream, cert_resolver, args, extension_registry, http_challenges, secure_file_server).await {
                                    eprintln!("HTTPS connection error: {}", e);
                                }
                            });
                        }
                        Err(e) => {
                            eprintln!("‚ùå HTTPS accept error: {}", e);
                        }
                    }
            }
        }

            // Process existing connections
            connections.retain(|conn| {
                // In a real implementation, you'd process the connection here
                // For this example, we just remove completed connections
                false
            });

            // Small delay to prevent busy waiting
            std::thread::sleep(Duration::from_millis(10));
        }
    }

    /// Handle HTTP connection (port 80) for ACME challenges and file serving
    async fn handle_http_connection(
        mut stream: tokio::net::TcpStream,
        #[cfg(feature = "acme")]
        acme_client: Option<Arc<AcmeClient>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Create connection policy for Keep-Alive decisions
        let connection_policy = ConnectionPolicy::default();
        let mut request_count = 0;

        // Keep-Alive loop: handle multiple requests on the same connection
        loop {
            // Read HTTP request
            let mut buffer = [0; 4096];
            let mut total_read = 0;

            // Read data in a loop to handle partial reads
            loop {
                match stream.read(&mut buffer[total_read..]).await {
                    Ok(0) => {
                        // Connection closed by client
                        println!("DEBUG: HTTP connection closed by client");
                        return Ok(());
                    }
                    Ok(n) => {
                        total_read += n;
                        if total_read >= buffer.len() {
                            break; // Buffer full
                        }
                        // Check if we have a complete HTTP request
                        if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                            if request_str.contains("\r\n\r\n") {
                                break; // Complete HTTP request received
                            }
                        }
                    }
                    Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                        // No data available, wait a bit
                        std::thread::sleep(std::time::Duration::from_millis(10));
                        continue;
                    }
                    Err(e) => return Err(e.into()),
                }
            }

        // Parse HTTP request
        let request = String::from_utf8_lossy(&buffer[..total_read]);
        let lines: Vec<&str> = request.lines().collect();

        // Parse HTTP version and connection header from request
        let (http_version, connection_header) = ConnectionPolicy::parse_request_info(&request);
        request_count += 1;

        // Determine if we should keep the connection alive
        let should_keep_alive = connection_policy.should_keep_alive(
            &http_version,
            connection_header.as_deref(),
            0, // We don't have response size here, but it's not critical for the decision
            request_count,
        );

        // Extract domain from Host header
        let domain = extract_domain_from_host_header(&request);

        println!("DEBUG: HTTP connection - total_read: {}", total_read);
        println!("DEBUG: HTTP request (first 200 bytes): {}", &request[..std::cmp::min(200, request.len())]);

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

            // Handle HTTP-01 ACME challenges
            if first_line.starts_with("GET /.well-known/acme-challenge/") {
                return Self::handle_acme_challenge_http(stream, first_line, &acme_client, &http_challenges).await;
            }
        }

        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                let path_with_query = &first_line[path_start + 1..];
                // Find the end of the path (either next space or query string)
                let path_end = if let Some(query_start) = path_with_query.find('?') {
                    query_start
                } else if let Some(space_pos) = path_with_query.find(' ') {
                    space_pos
                } else {
                    path_with_query.len()
                };
                &path_with_query[..path_end]
            } else {
                "/"
            }
        } else {
            "/"
        };
        println!("DEBUG: Full request: {}", request);

        // Check for bin extension requests (CGI-like)
        if request_path.starts_with("/cgi-bin/") {
            // Extract query string from the original request line
            let query_string = if let Some(first_line) = lines.first() {
                if let Some(path_start) = first_line.find(' ') {
                    let path_with_query = &first_line[path_start + 1..];
                    if let Some(query_start) = path_with_query.find('?') {
                        let query_part = &path_with_query[query_start + 1..];
                        // Find the end of the query string (next space)
                        if let Some(space_pos) = query_part.find(' ') {
                            &query_part[..space_pos]
                        } else {
                            query_part
                        }
                    } else {
                        ""
                    }
                } else {
                    ""
                }
            } else {
                ""
            };

            // Extract the path without query string (already done above)
            let bin_path = request_path;

            // Parse headers
            let mut headers = std::collections::HashMap::new();
            for line in &lines[1..] {
                if let Some(colon_pos) = line.find(':') {
                    let header_name = line[..colon_pos].trim().to_lowercase();
                    let header_value = line[colon_pos + 1..].trim().to_string();
                    headers.insert(header_name, header_value);
                }
            }

            // Handle bin extension request
            let response = {
                let registry = extension_registry.lock().unwrap();
                registry.handle_bin_request(bin_path, "GET", query_string, &headers)
            };

            match response {
                Ok(response) => {
                    stream.write_all(response.as_bytes()).await?;
                    stream.flush().await?;
                    return Ok(());
                }
                Err(e) => {
                    let error_msg = format!("Error: {}", e);
                    let error_response = format!(
                        "HTTP/1.1 500 Internal Server Error\r\n\
                         Content-Type: text/plain\r\n\
                         Content-Length: {}\r\n\
                         \r\n\
                         {}",
                        error_msg.len(),
                        error_msg
                    );
                    stream.write_all(error_response.as_bytes()).await?;
                    stream.flush().await?;
                    return Ok(());
                }
            }
        }

        // Check for admin extension requests
        #[cfg(feature = "extensions")]
        {
            println!("DEBUG: Checking for admin request with path: {}", request_path);
            println!("DEBUG: Admin request check: comment_={}, math_={}, example_={}",
                request_path.starts_with("/comment_"),
                request_path.starts_with("/math_"),
                request_path.starts_with("/example_"));
            // Check if this looks like an admin request (starts with /comment_, /math_, etc.)
            if request_path.starts_with("/comment_") || request_path.starts_with("/math_") || request_path.starts_with("/example_") {
                println!("DEBUG: Admin request detected for path: {}", request_path);

                // Extract HTTP method from the first line
                let http_method = if let Some(first_line) = lines.first() {
                    first_line.split_whitespace().next().unwrap_or("GET")
                } else {
                    "GET"
                };
                println!("DEBUG: HTTP method: {}", http_method);

                // Extract query string from the request
                let query_string = if let Some(query_start) = request_path.find('?') {
                    &request_path[query_start + 1..]
                } else {
                    ""
                };

                // Extract the path without query string
                let admin_path = if let Some(query_start) = request_path.find('?') {
                    &request_path[..query_start]
                } else {
                    request_path
                };

                // Parse headers
                let mut headers = std::collections::HashMap::new();
                let mut body = String::new();
                let mut in_body = false;

                for line in &lines[1..] {
                    if in_body {
                        body.push_str(line);
                        body.push('\n');
                    } else if line.is_empty() {
                        in_body = true; // Empty line indicates start of body
                    } else if let Some(colon_pos) = line.find(':') {
                        let header_name = line[..colon_pos].trim().to_lowercase();
                        let header_value = line[colon_pos + 1..].trim().to_string();
                        headers.insert(header_name, header_value);
                    }
                }

                // Remove trailing newline from body
                if body.ends_with('\n') {
                    body.pop();
                }

                // Handle admin extension request
                let admin_response = extension_registry.lock().unwrap().process_admin_request(admin_path, http_method, query_string, &body, &headers);
                match admin_response {
                    Ok(response) => {
                        stream.write_all(response.as_bytes()).await?;
                        stream.flush().await?;
                        return Ok(());
                    }
                    Err(e) => {
                        let error_response = format!(
                            "HTTP/1.1 500 Internal Server Error\r\n\
                             Content-Type: text/plain\r\n\
                             Content-Length: {}\r\n\
                             \r\n\
                             Error: {}",
                            e.to_string().len(),
                            e
                        );
                        stream.write_all(error_response.as_bytes()).await?;
                        stream.flush().await?;
                        return Ok(());
                    }
                }
            }
        }

        println!("Requested path: {}", request_path);

        // Try to serve the requested file using secure file server with domain-specific document root
        let serve_result = secure_file_server.serve_file_with_domain(request_path, domain.as_deref());
        match serve_result {
            Ok(Some(file_content)) => {
                // Check if this is a redirect response (starts with "HTTP/1.1 301")
                if file_content.starts_with(b"HTTP/1.1 301") {
                    // This is a redirect response, send it directly
                    stream.write_all(&file_content).await?;
                    stream.flush().await?;
                } else {
                    // This is regular file content, process extensions if it's HTML
                    let mut processed_content = file_content.clone();

                    // Check if this is HTML content that needs extension processing
                    if let Ok(content_string) = String::from_utf8(file_content.clone()) {
                        // Process extensions in the HTML content
                        #[cfg(feature = "extensions")]
                        {
                            let processed_html = extension_registry.lock().unwrap().process_html(&content_string, request_path);
                            processed_content = processed_html.into_bytes();
                        }
                    }

                    // For directory index files, we need to determine the actual file path for MIME type detection
                    let file_path_for_mime = if request_path.ends_with('/') {
                        // This is a directory request, determine the actual index file
                        let clean_path = request_path.trim_start_matches('/');
                        let domain_doc_root = secure_file_server.get_domain_document_root(domain.as_deref().unwrap_or(""));
                        let dir_path = domain_doc_root.join(clean_path);
                        let index_html = dir_path.join("index.html");
                        let index_htm = dir_path.join("index.htm");

                        if index_html.exists() {
                            index_html
                        } else if index_htm.exists() {
                            index_htm
                        } else {
                            std::path::PathBuf::from("index.html") // fallback
                        }
                    } else {
                        std::path::PathBuf::from(request_path)
                    };

                    // Generate HTTP response with proper MIME type
                    let mime_type = secure_file_server.get_mime_type(&file_path_for_mime);
                    let content_length = processed_content.len();

                    // Use HttpResponse builder for version-aware response
                    let mut response = HttpResponse::ok(processed_content.clone());
                    response.set_content_type(&mime_type);
                    response.set_content_length();
                    response.add_security_headers();

                    let response_headers = response.encode(&http_version, should_keep_alive);

                    // Write response (headers + content) in chunks to handle large files
                    let response_bytes = &response_headers;

                    // Write complete response (headers + content)
                    stream.write_all(response_bytes).await?;
                    stream.flush().await?;
                }
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                } else {
                    // File not found, send 404 for non-root requests
                    let mut response = HttpResponse::not_found(b"Not Found".to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                let error_msg = format!("{}", e);
                println!("Request denied for {}: {}", request_path, error_msg);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                } else {
                    // Send 404 for non-root requests with security errors
                    let mut response = HttpResponse::not_found(b"Not Found".to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                }
            }
        }

        // Check if we should keep the connection alive for the next request
        if !should_keep_alive {
            println!("DEBUG: Closing HTTP connection after {} requests (version: {})",
                request_count, http_version);
            break; // Exit the Keep-Alive loop
        }

        println!("DEBUG: Keeping HTTP connection alive for next request (version: {})",
            http_version);
        }

        Ok(())
    }

    /// Handle a single HTTPS connection (static version for threading)
    async fn handle_connection_static(
        stream: tokio::net::TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç Starting HTTPS connection handling");

        // Convert tokio::net::TcpStream to std::net::TcpStream for rustls
        let std_stream = stream.into_std()?;

        // Run the TLS handshake in a blocking context
        let result = tokio::task::spawn_blocking(move || {
            Self::handle_https_connection_blocking(
                std_stream,
                cert_resolver,
                args,
                extension_registry,
                http_challenges,
                secure_file_server,
            )
        }).await??;

        Ok(result)
    }

    /// Handle HTTPS connection in blocking context (for rustls compatibility)
    fn handle_https_connection_blocking(
        mut stream: std::net::TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç Starting blocking HTTPS connection handling");

        // Create server config with our certificate resolver
        // Use ring provider for better Safari 6-8 compatibility
        let server_config = ServerConfig::builder_with_provider(
            rustls::crypto::ring::default_provider().into()
        )
        .with_no_client_auth()
        .with_cert_resolver(cert_resolver)
        .map_err(|e| {
            println!("‚ùå Failed to create server config: {}", e);
            format!("Failed to create server config: {}", e)
        })?;

        println!("‚úÖ Server config created successfully");

        // Create a new acceptor for this connection
        let mut acceptor = Acceptor::default();

        // Read TLS packets until we have a complete ClientHello
        let accepted = loop {
            match acceptor.read_tls(&mut stream) {
                Ok(0) => {
                    println!("üîç Connection closed by client");
                    return Ok(()); // Connection closed
                }
                        Ok(_) => {
                            match acceptor.accept() {
                    Ok(Some(accepted)) => {
                        break accepted;
                    }
                    Ok(None) => {
                        continue;
                    }
                        Err((e, mut alert)) => {
                            println!("‚ùå Error accepting connection: {}", e);
                            let _ = alert.write_all(&mut stream);
                            return Err(format!("Error accepting connection: {}", e).into());
                        }
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, continue
                    continue;
                }
                Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
                    println!("üîç Client disconnected unexpectedly");
                    return Ok(());
                }
                Err(e) => {
                    println!("‚ùå Error reading TLS: {}", e);
                    return Err(e.into());
                }
            }
        };

        // Get the server name from ClientHello
        let server_name = accepted.client_hello().server_name()
            .map(|name| name.as_ref().to_string())
            .unwrap_or_else(|| "unknown".to_string());

        // Complete the TLS handshake
        let mut conn = match accepted.into_connection(Arc::new(server_config)) {
            Ok(conn) => {
                println!("‚úÖ TLS handshake completed successfully for domain: {}", server_name);
                conn
            }
            Err((e, mut alert)) => {
                println!("‚ùå Error completing TLS handshake: {}", e);
                println!("üîç Error details: {:?}", e);
                let _ = alert.write_all(&mut stream);
                return Err(format!("Error completing connection: {}", e).into());
            }
        };

        // Handle the connection
        println!("üîç About to call process_https_request_static for domain: {}", server_name);
        Self::process_https_request_static_blocking(&mut stream, &mut conn, &server_name, &extension_registry, &http_challenges, &secure_file_server)?;
        println!("üîç process_https_request_static completed for domain: {}", server_name);

        Ok(())
    }

    /// Handle a single HTTPS connection

    /// Handle admin request for HTTPS (centralized)
    #[cfg(feature = "extensions")]
    fn handle_admin_request_https(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_path: &str,
        lines: &[&str],
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("DEBUG: Admin request detected for path: {}", request_path);

        // Extract HTTP method from the first line
        let http_method = if let Some(first_line) = lines.first() {
            first_line.split_whitespace().next().unwrap_or("GET")
        } else {
            "GET"
        };
        println!("DEBUG: HTTP method: {}", http_method);

        // Extract query string from the request
        let query_string = if let Some(query_start) = request_path.find('?') {
            &request_path[query_start + 1..]
        } else {
            ""
        };

        // Extract the path without query string
        let admin_path = if let Some(query_start) = request_path.find('?') {
            &request_path[..query_start]
        } else {
            request_path
        };

        // Parse headers
        let mut headers = std::collections::HashMap::new();
        let mut body = String::new();
        let mut in_body = false;

        for line in &lines[1..] {
            if in_body {
                body.push_str(line);
                body.push('\n');
            } else if line.is_empty() {
                in_body = true; // Empty line indicates start of body
            } else if let Some(colon_pos) = line.find(':') {
                let header_name = line[..colon_pos].trim().to_lowercase();
                let header_value = line[colon_pos + 1..].trim().to_string();
                headers.insert(header_name, header_value);
            }
        }

        // Remove trailing newline from body
        if body.ends_with('\n') {
            body.pop();
        }

        // Handle admin extension request using the centralized system
        let admin_response = extension_registry.lock().unwrap().process_admin_request(admin_path, http_method, query_string, &body, &headers);
        match admin_response {
            Ok(response) => {
                conn.writer().write_all(response.as_bytes())?;
                conn.write_tls(stream)?;
                conn.complete_io(stream)?;
                Ok(())
            }
            Err(e) => {
                let error_response = format!(
                    "HTTP/1.1 500 Internal Server Error\r\n\
                     Content-Type: text/plain\r\n\
                     Content-Length: {}\r\n\
                     \r\n\
                     Error: {}",
                    e.to_string().len(),
                    e
                );
                conn.writer().write_all(error_response.as_bytes())?;
                conn.write_tls(stream)?;
                conn.complete_io(stream)?;
                Ok(())
            }
        }
    }

    /// Process HTTPS request and send response (blocking version for rustls)
    fn process_https_request_static_blocking(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: &SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç process_https_request_static started for domain: {}", server_name);
        // TLS handshake is already completed in the main connection handler
        println!("üîç TLS handshake already completed for domain: {}", server_name);

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        println!("üîç Starting to read HTTP request for domain: {}", server_name);

        // TLS I/O is already completed in the main connection handler
        println!("üîç TLS I/O already completed for domain: {}", server_name);

        // Read data in a loop to handle partial reads
        let mut read_attempts = 0;
        const MAX_READ_ATTEMPTS: usize = 1000; // 10 seconds with 10ms sleep

        loop {
            read_attempts += 1;
            if read_attempts > MAX_READ_ATTEMPTS {
                println!("üîç Timeout waiting for HTTP request from domain: {}", server_name);
                return Err("Timeout waiting for HTTP request".into());
            }

            //println!("üîç Attempting to read data for domain: {} (total_read: {}, attempt: {})", server_name, total_read, read_attempts);

            // First, try to complete any pending TLS I/O
            match conn.complete_io(stream) {
                Ok((0, 0)) => {
                    println!("üîç Connection closed for domain: {}", server_name);
                    break; // Connection closed
                }
                Ok(_) => {
                    // TLS I/O completed, now try to read data
                    match conn.reader().read(&mut buffer[total_read..]) {
                        Ok(0) => {
                            println!("üîç Connection closed for domain: {}", server_name);
                            break; // Connection closed
                        }
                        Ok(n) => {
                            println!("üîç Read {} bytes for domain: {}", n, server_name);
                            total_read += n;
                            if total_read >= buffer.len() {
                                println!("üîç Buffer full for domain: {}", server_name);
                                break; // Buffer full
                            }
                            // Check if we have a complete HTTP request
                            if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                                println!("üîç Current request data for domain {}: {}", server_name, request_str);
                                if request_str.contains("\r\n\r\n") {
                                    println!("üîç Complete HTTP request received for domain: {}", server_name);
                                    break; // Complete HTTP request received
                                }
                            }
                        }
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                            println!("üîç WouldBlock error for domain: {}, waiting... (attempt {})", server_name, read_attempts);
                            // No data available, wait a bit
                            std::thread::sleep(std::time::Duration::from_millis(10));
                            continue;
                        }
                        Err(e) => {
                            println!("üîç Read error for domain {}: {}", server_name, e);
                            return Err(e.into());
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    //println!("üîç TLS I/O WouldBlock for domain: {}, waiting... (attempt {})", server_name, read_attempts);
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => {
                    println!("üîç TLS I/O error for domain {}: {}", server_name, e);
                    return Err(e.into());
                }
            }
        }

        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       return Self::handle_acme_challenge_static(stream, conn, first_line, &None, http_challenges);
                   }
        }


        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                let path_with_query = &first_line[path_start + 1..];
                // Find the end of the path (either next space or query string)
                let path_end = if let Some(query_start) = path_with_query.find('?') {
                    query_start
                } else if let Some(space_pos) = path_with_query.find(' ') {
                    space_pos
                } else {
                    path_with_query.len()
                };
                &path_with_query[..path_end]
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        // Check for admin extension requests
        #[cfg(feature = "extensions")]
        {
            if request_path.starts_with("/comment_") || request_path.starts_with("/math_") || request_path.starts_with("/example_") {
                return Self::handle_admin_request_https(stream, conn, request_path, &lines, extension_registry);
            }
        }

        // Check for bin extension requests (CGI-like)
        if request_path.starts_with("/cgi-bin/") {
            // Extract query string from the original request line
            let query_string = if let Some(first_line) = lines.first() {
                if let Some(path_start) = first_line.find(' ') {
                    let path_with_query = &first_line[path_start + 1..];
                    if let Some(query_start) = path_with_query.find('?') {
                        let query_part = &path_with_query[query_start + 1..];
                        if let Some(space_pos) = query_part.find(' ') {
                            &query_part[..space_pos]
                        } else {
                            query_part
                        }
                    } else {
                        ""
                    }
                } else {
                    ""
                }
            } else {
                ""
            };

            // Extract the path without query string (already done above)
            let bin_path = request_path;

            // Parse headers
            let mut headers = std::collections::HashMap::new();
            for line in &lines[1..] {
                if let Some(colon_pos) = line.find(':') {
                    let header_name = line[..colon_pos].trim().to_lowercase();
                    let header_value = line[colon_pos + 1..].trim().to_string();
                    headers.insert(header_name, header_value);
                }
            }

            // Handle bin extension request
            let response = {
                let registry = extension_registry.lock().unwrap();
                registry.handle_bin_request(bin_path, "GET", query_string, &headers)
            };

            match response {
                Ok(response_body) => {
                    conn.writer().write_all(response_body.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                    return Ok(());
                }
                Err(e) => {
                    let error_response = format!(
                        "HTTP/1.1 500 Internal Server Error\r\n\
                         Content-Type: text/plain\r\n\
                         Content-Length: {}\r\n\
                         \r\n\
                         Error: {}",
                        e.to_string().len(),
                        e
                    );
                    conn.writer().write_all(error_response.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                    return Ok(());
                }
            }
        }

        // Try to serve the requested file using secure file server with domain-specific document root
        match secure_file_server.serve_file_with_domain(request_path, Some(server_name)) {
            Ok(Some(file_content)) => {
                // Check if this is a redirect response (starts with "HTTP/1.1 301")
                if file_content.starts_with(b"HTTP/1.1 301") {
                    // This is a redirect response, send it directly
                    conn.writer().write_all(&file_content)?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // This is regular file content, process extensions if it's HTML
                    let mut processed_content = file_content.clone();

                    // Check if this is HTML content that needs extension processing
                    if let Ok(content_string) = String::from_utf8(file_content.clone()) {
                        // Process extensions in the HTML content
                        #[cfg(feature = "extensions")]
                        {
                            let processed_html = extension_registry.lock().unwrap().process_html(&content_string, request_path);
                            processed_content = processed_html.into_bytes();
                        }
                    }

                    // For directory index files, we need to determine the actual file path for MIME type detection
                    let file_path_for_mime = if request_path.ends_with('/') {
                        // This is a directory request, determine the actual index file
                        let clean_path = request_path.trim_start_matches('/');
                        let domain_doc_root = secure_file_server.get_domain_document_root(server_name);
                        let dir_path = domain_doc_root.join(clean_path);
                        let index_html = dir_path.join("index.html");
                        let index_htm = dir_path.join("index.htm");

                        if index_html.exists() {
                            index_html
                        } else if index_htm.exists() {
                            index_htm
                        } else {
                            std::path::PathBuf::from("index.html") // fallback
                        }
                    } else {
                        std::path::PathBuf::from(request_path)
                    };

                    // Generate HTTP response with proper MIME type
                    let mime_type = secure_file_server.get_mime_type(&file_path_for_mime);
                    let content_length = processed_content.len();

                    let response_headers = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: {}\r\n\
                         Content-Length: {}\r\n\
                         X-Content-Type-Options: nosniff\r\n\
                         X-Frame-Options: DENY\r\n\
                         X-XSS-Protection: 1; mode=block\r\n\
                         Cache-Control: no-cache\r\n\
                         Connection: close\r\n\
                         \r\n",
                        mime_type,
                        content_length
                    );

                    // Write headers first
                    conn.writer().write_all(response_headers.as_bytes())?;
                    conn.write_tls(stream)?;

                    // Write content in chunks with proper partial write handling
                    const CHUNK_SIZE: usize = 8192; // 8KB chunks
                    let mut offset = 0;
                    while offset < processed_content.len() {
                        let chunk_end = std::cmp::min(offset + CHUNK_SIZE, processed_content.len());
                        let chunk = &processed_content[offset..chunk_end];

                        // Handle partial writes properly
                        let mut written = 0;
                        while written < chunk.len() {
                            match conn.writer().write(&chunk[written..]) {
                                Ok(n) => {
                                    written += n;
                                    if written < chunk.len() {
                                        // Partial write, try to flush and continue
                                        conn.write_tls(stream)?;
                                    }
                                }
                                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                                    // Would block, try to flush and retry
                                    conn.write_tls(stream)?;
                                    continue;
                                }
                                Err(e) => return Err(e.into()),
                            }
                        }

                        offset = chunk_end;
                    }

                    // Final flush and complete I/O
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                }
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page(server_name);
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );

                    conn.writer().write_all(response.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // File not found, send 404 for non-root requests
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                println!("Request denied for {}: {}", request_path, e);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page(server_name);
                    let response = format!(
                        "HTTP/1.1 200 OK\r\n\
                         Content-Type: text/html; charset=utf-8\r\n\
                         Content-Length: {}\r\n\
                         Connection: close\r\n\
                         \r\n\
                         {}",
                        default_page.len(),
                        default_page
                    );

                    conn.writer().write_all(response.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // Send 404 for non-root requests with security errors
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
        }

        Ok(())
    }

    /// Process HTTPS request and send response
    fn process_https_request(
        &self,
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Complete the handshake
        conn.complete_io(stream)?;

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        // Read data in a loop to handle partial reads
        loop {
            match conn.reader().read(&mut buffer[total_read..]) {
                Ok(0) => break, // Connection closed
                Ok(n) => {
                    total_read += n;
                    if total_read >= buffer.len() {
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        if request_str.contains("\r\n\r\n") {
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        }

        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       return Self::handle_acme_challenge(stream, conn, first_line, &self.acme_client, http_challenges);
                   }
        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                if let Some(path_end) = first_line[path_start + 1..].find(' ') {
                    &first_line[path_start + 1..path_start + 1 + path_end]
                } else {
                    "/"
                }
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        }
        // Try to serve the requested file using secure file server with domain-specific document root
        let request_path = "/"; // Default to root path
        match self.secure_file_server.serve_file_with_domain(request_path, Some(server_name)) {
            Ok(Some(file_content)) => {
                // Successfully served a file
                match self.secure_file_server.generate_http_response(request_path, file_content.as_slice()) {
                    Ok(response_headers) => {
                        // Write headers first
                        conn.writer().write_all(response_headers.as_bytes())?;
                        conn.write_tls(stream)?;

                        // Write content in chunks with proper partial write handling
                        const CHUNK_SIZE: usize = 8192; // 8KB chunks
                        let mut offset = 0;
                        while offset < file_content.len() {
                            let chunk_end = std::cmp::min(offset + CHUNK_SIZE, file_content.len());
                            let chunk = &file_content[offset..chunk_end];

                            // Handle partial writes properly
                            let mut written = 0;
                            while written < chunk.len() {
                                match conn.writer().write(&chunk[written..]) {
                                    Ok(n) => {
                                        written += n;
                                        if written < chunk.len() {
                                            // Partial write, try to flush and continue
                                            conn.write_tls(stream)?;
                                        }
                                    }
                                    Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                                        // Would block, try to flush and retry
                                        conn.write_tls(stream)?;
                                        continue;
                                    }
                                    Err(e) => return Err(e.into()),
                                }
                            }

                            offset = chunk_end;
                        }

                        // Final flush and complete I/O
                        conn.write_tls(stream)?;
                        conn.complete_io(stream)?;
                    }
                    Err(e) => {
                        println!("Error generating HTTP response: {}", e);
                        Self::send_error_response(conn, stream, 500, "Internal Server Error")?;
                    }
                }
            }
            Ok(None) => {
                // File not found, send 404
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
            Err(e) => {
                // Security error or other error, send 403 or 404 for security
                println!("Request denied for {}: {}", request_path, e);
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
        }

        Ok(())
    }

    /// Send an error response (static version for threading)
    fn send_error_response_static(
        conn: &mut ServerConnection,
        stream: &mut std::net::TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>easyp HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        let response = format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: text/html; charset=utf-8\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n\
             {}",
            status_code, status_text, body.len(), body
        );

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Send an error response
    fn send_error_response(
        conn: &mut ServerConnection,
        stream: &mut std::net::TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>easyp HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        let response = format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: text/html; charset=utf-8\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n\
             {}",
            status_code, status_text, body.len(), body
        );

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTP (port 80)
    async fn handle_acme_challenge_http(
        mut stream: tokio::net::TcpStream,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        stream.write_all(response.as_bytes()).await?;
        stream.flush().await?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443) - static version for threading
    fn handle_acme_challenge_static(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params_static(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443)
    fn handle_acme_challenge(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);
            format!(
                "HTTP/1.1 200 OK\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: {}\r\n\
                 Cache-Control: no-cache\r\n\
                 Connection: close\r\n\
                 \r\n\
                 {}",
                key_auth.len(),
                key_auth
            )
        } else {
            println!("Challenge token not found: {}", token);
            format!(
                "HTTP/1.1 404 Not Found\r\n\
                 Content-Type: text/plain\r\n\
                 Content-Length: 13\r\n\
                 Connection: close\r\n\
                 \r\n\
                 Not Found"
            )
        };

        conn.writer().write_all(response.as_bytes())?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Get challenge response for a token from ACME client
    fn get_challenge_response(&self, token: &str) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = &self.acme_client {
            let rt = tokio::runtime::Runtime::new().unwrap();
            if let Some(response) = rt.block_on(acme_client.get_challenge_response(token)) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = self.http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params_static(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            // Use block_in_place to handle the async call within the existing runtime
            if let Some(response) = tokio::task::block_in_place(|| {
                tokio::runtime::Handle::try_current()
                    .unwrap()
                    .block_on(acme_client.get_challenge_response(token))
            }) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            // Use block_in_place to handle the async call within the existing runtime
            if let Some(response) = tokio::task::block_in_place(|| {
                tokio::runtime::Handle::try_current()
                    .unwrap()
                    .block_on(acme_client.get_challenge_response(token))
            }) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    // No more challenge syncing needed - challenges are accessed directly from ACME client
}


/// Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
fn ensure_tmp_acme_permissions(uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    let tmp_acme_dir = "/tmp/acme_certs";

    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to create /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set ownership to www-data
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755
    let output = Command::new("chmod")
        .args(&["-R", "755", tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("Certificate cache directory permissions set: {} (owner: {})", tmp_acme_dir, uid);
    Ok(())
}

// DomainRequestLogger removed - was unused dead code


/// Ensure certificate cache directory has proper ownership for www-data
fn ensure_cert_cache_permissions(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to create certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Create subdirectories that ACME client needs (based on environment)
    let staging_dir = format!("{}/staging", cache_dir);
    let production_dir = format!("{}/production", cache_dir);

    for dir in [&staging_dir, &production_dir] {
        let output = Command::new("mkdir")
            .args(&["-p", dir])
            .output()?;

        if !output.status.success() {
            return Err(format!("Failed to create certificate directory {}: {}", dir, String::from_utf8_lossy(&output.stderr)).into());
        }
    }

    // Set ownership to www-data recursively
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755 recursively
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("Certificate cache directory permissions set: {} (owner: {})", cache_dir, uid);
    Ok(())
}

/// Ensure ACME cache directory is properly set up with www-data permissions
fn ensure_acme_cache_directory(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    // Create the main cache directory
    std::fs::create_dir_all(cache_dir)?;

    // Create the acme_lib subdirectory
    let acme_lib_dir = format!("{}/acme_lib", cache_dir);
    //TODO
    std::fs::create_dir_all(&acme_lib_dir)?;

    // Set ownership to www-data for both directories
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755 for both directories
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("ACME cache directory permissions set: {} (owner: {})", cache_dir, uid);
    println!("ACME lib directory created: {}", acme_lib_dir);
    Ok(())
}

/// Check if www-data user exists by parsing /etc/passwd (Redox-specific)
#[cfg(target_os = "redox")]
fn check_www_data_user_exists() -> Result<bool, Box<dyn std::error::Error>> {
    use std::fs;
    use std::io::{BufRead, BufReader};

    let passwd_content = fs::read_to_string("/etc/passwd")?;
    let reader = BufReader::new(passwd_content.as_bytes());

    for line in reader.lines() {
        let line = line?;
        //Redox uses ; instead of :?
        let parts: Vec<&str> = line.split(';').collect();

        if parts.len() >= 1 && parts[0] == "www-data" {
            return Ok(true);
        }
    }

    Ok(false)
}

/// Ensure www-data user exists, create if necessary
#[cfg(unix)]
fn ensure_www_data_user() -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    #[cfg(target_os = "redox")]
    {
        // For Redox, check /etc/passwd instead of using id command
        if check_www_data_user_exists()? {
            // User exists, nothing to do
            return Ok(());
        }
    }

    #[cfg(not(target_os = "redox"))]
    {
        // For other Unix systems, use the id command as before
        // Check if www-data user exists
        let check_output = Command::new("id")
            .args(&["-u", "www-data"])
            .output()?;

        if check_output.status.success() {
            // User exists, nothing to do
            return Ok(());
        }
    }

    println!("www-data user not found, creating...");

    // Create www-data group first
    #[cfg(not(target_os = "redox"))]
    let group_output = Command::new("groupadd")
        .args(&["www-data"])
        .output()?;
    //docker run -v D:\src\easyp:/easyp -v D:\src\ring-redox:/ring-redox -it docker.io/redoxos/redoxer:latest
    #[cfg(not(target_os = "redox"))]
    if !group_output.status.success() {
        let stderr = String::from_utf8_lossy(&group_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data group: {}", stderr).into());
        }
    }

    // Create www-data user
    #[cfg(not(target_os = "redox"))]
    let user_output = Command::new("useradd")
        .args(&["-r", "-g", "www-data", "-s", "/bin/false", "-d", "/var/www", "www-data"])
        .output()?;

    #[cfg(target_os = "redox")]
    let user_output = Command::new("useradd")
        .args(&["-s", "/bin/false", "www-data"])
        .output()?;
    #[cfg(target_os = "redox")]
    {

    // then sleep for a second
    //std::thread::sleep(std::time::Duration::from_secs(10));
    println!("user_output: {:?}", user_output);
    println!("user_output.status: {:?}", user_output.status);
    println!("user_output.stdout: {:?}", user_output.stdout);
    println!("user_output.stderr: {:?}", user_output.stderr);

    // Print the contents of /etc/passwd for diagnostic purposes

        use std::fs;
        match fs::read_to_string("/etc/passwd") {
            Ok(contents) => {
                println!("Contents of /etc/passwd:\n{}", contents);
            }
            Err(e) => {
                println!("Failed to read /etc/passwd: {}", e);
            }
        }
    }




    if !user_output.status.success() {
        let stderr = String::from_utf8_lossy(&user_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data user: {}", stderr).into());
        }
    }

    println!("‚úÖ www-data user created successfully");
    Ok(())
}

/// Parse /etc/passwd to get www-data UID and GID (Redox-specific)
#[cfg(target_os = "redox")]
fn parse_www_data_from_passwd() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    use std::fs;
    use std::io::{BufRead, BufReader};

    let passwd_content = fs::read_to_string("/etc/passwd")?;
    let reader = BufReader::new(passwd_content.as_bytes());

    for line in reader.lines() {
        let line = line?;
        let parts: Vec<&str> = line.split(';').collect();

        // /etc/passwd format: username:password:uid:gid:gecos:home:shell
        if parts.len() >= 4 && parts[0] == "www-data" {
            let uid = parts[1].parse::<u32>()?;
            let gid = parts[2].parse::<u32>()?;
            return Ok((uid, gid));
        }
    }

    Err("www-data user not found in /etc/passwd".into())
}

/// Look up the UID and GID for the www-data user
#[cfg(unix)]
fn get_www_data_uid_gid() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    // Ensure www-data user exists first
    ensure_www_data_user()?;

    #[cfg(target_os = "redox")]
    {
        // For Redox, parse /etc/passwd instead of using id command
        parse_www_data_from_passwd()
    }

    #[cfg(not(target_os = "redox"))]
    {
        // For other Unix systems, use the id command as before
        use std::process::Command;

        // Try to get UID for www-data
        let uid_output = Command::new("id")
            .args(&["-u", "www-data"])
            .output()?;

        if !uid_output.status.success() {
            return Err("www-data user not found after creation attempt".into());
        }

        let uid_str = String::from_utf8(uid_output.stdout)?;
        let uid = uid_str.trim().parse::<u32>()?;

        // Try to get GID for www-data
        let gid_output = Command::new("id")
            .args(&["-g", "www-data"])
            .output()?;

        if !gid_output.status.success() {
            return Err("www-data group not found".into());
        }

        let gid_str = String::from_utf8(gid_output.stdout)?;
        let gid = gid_str.trim().parse::<u32>()?;

        Ok((uid, gid))
    }
}

/// Fallback for non-UNIX systems - returns dummy values
#[cfg(not(unix))]
fn get_www_data_uid_gid() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    println!("Warning: Running without unix feature - using dummy UID/GID values");
    Ok((1000, 1000)) // Dummy values for non-UNIX systems
}

/// Automatically detect the server's IP addresses from network interfaces
#[cfg(not(target_os = "redox"))]
fn detect_server_ips() -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    use get_if_addrs::{get_if_addrs, IfAddr};

    let interfaces = get_if_addrs()?;
    let mut ip_addresses = Vec::new();

    for interface in interfaces {
        match interface.addr {
            IfAddr::V4(ipv4) => {
                let ip = ipv4.ip;
                // Filter out localhost and loopback addresses
                if !ip.is_loopback() && !ip.is_unspecified() {
                    ip_addresses.push(IpAddr::V4(ip));
                }
            }
            IfAddr::V6(ipv6) => {
                let ip = ipv6.ip;
                // Filter out localhost and loopback addresses
                if !ip.is_loopback() && !ip.is_unspecified() {
                    ip_addresses.push(IpAddr::V6(ip));
                }
            }
        }
    }

    println!("Detected {} IP addresses: {:?}", ip_addresses.len(), ip_addresses);
    Ok(ip_addresses)
}

/// Parse comma-separated IP addresses
fn parse_allowed_ips(ips_str: &str) -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    let mut ips = Vec::new();

    for ip_str in ips_str.split(',') {
        let ip_str = ip_str.trim();
        if ip_str.is_empty() {
            continue;
        }

        let ip: IpAddr = ip_str.parse()?;
        ips.push(ip);
    }

    Ok(ips)
}

/// Get admin keys from the admin_keys file
fn get_admin_keys() -> Result<std::collections::HashMap<String, String>, Box<dyn std::error::Error>> {
    let admin_keys_file = std::path::Path::new("/var/lib/easyp/admin_keys");
    let mut admin_keys = std::collections::HashMap::new();

    if admin_keys_file.exists() {
        if let Ok(content) = std::fs::read_to_string(admin_keys_file) {
            for line in content.lines() {
                // Format is: extension_name_key (e.g., comment_71f8732b179e9339)
                // We need the full key including the underscore
                if let Some(underscore_pos) = line.find('_') {
                    let ext_name = &line[..underscore_pos];
                    let full_key = &line[underscore_pos..]; // Include the underscore in the key
                    admin_keys.insert(ext_name.to_string(), full_key.to_string());
                }
            }
        }
    }

    Ok(admin_keys)
}

/// Get domains from certificate cache and add localhost
fn get_domains(cache_dir: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let mut domains = Vec::new();

    // Add localhost
    domains.push("localhost".to_string());

    // Scan certificate cache directory for domains (both staging and production)
    let cache_path = std::path::Path::new(cache_dir);
    if cache_path.exists() {
        // Check both staging and production subdirectories
        for subdir in ["staging", "production"] {
            let subdir_path = cache_path.join(subdir);
            if subdir_path.exists() {
                if let Ok(entries) = std::fs::read_dir(&subdir_path) {
                    for entry in entries {
                        if let Ok(entry) = entry {
                            if let Some(file_name) = entry.file_name().to_str() {
                                // Look for various certificate file patterns
                                if file_name.ends_with(".crt") || file_name.ends_with(".pem") {
                                    // Extract domain from filename patterns like:
                                    // - ca.dansted.org.crt
                                    // - 1234567890_crt_ca_dansted_org.crt
                                    // - 1234567890_crt_www_dansted_org.crt
                                    let domain = if file_name.contains("_crt_") {
                                        // Pattern: 1234567890_crt_domain_name.crt
                                        if let Some(start) = file_name.find("_crt_") {
                                            let domain_part = &file_name[start + 5..];
                                            let domain_part = domain_part.trim_end_matches(".crt");
                                            // Replace underscores with dots
                                            domain_part.replace("_", ".")
                                        } else {
                                            continue;
                                        }
                                    } else {
                                        // Pattern: domain.com.crt
                                        file_name.trim_end_matches(".crt").trim_end_matches(".pem").to_string()
                                    };

                                    // Filter out non-domain filenames (like "fullchain", "privkey", etc.)
                                    if !domain.is_empty()
                                        && !domains.contains(&domain)
                                        && domain.contains(".")
                                        && !domain.starts_with("cached_")
                                        && !domain.starts_with("fullchain")
                                        && !domain.starts_with("privkey")
                                        && !domain.starts_with("acme_") {
                                        domains.push(domain);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(domains)
}

/// Print admin URLs for all domains and admin keys
fn print_admin_urls(args: &Args) -> Result<(), Box<dyn std::error::Error>> {
    let admin_keys = get_admin_keys()?;
    let domains = get_domains(&args.cache_dir)?;

    if admin_keys.is_empty() {
        println!("No admin keys found in /var/lib/easyp/admin_keys");
        return Ok(());
    }

    println!("Admin URLs:");
    for domain in domains {
        for (ext_name, key) in &admin_keys {
            let admin_url = format!("https://{}/{}{}", domain, ext_name, key);
            println!("{}", admin_url);
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    debug_extensions_enabled();
    println!("üöÄ easyp HTTPS Server starting - Debug version with enhanced ACME integration");
    let args = Args::parse().unwrap_or_else(|e| {
        eprintln!("Error parsing arguments: {}", e);
        eprintln!("Use --help for usage information");
        std::process::exit(1);
    });

    // Handle --admin-urls option
    if args.admin_urls {
        print_admin_urls(&args)?;
        return Ok(());
    }

    // Initialize simple logging
    if args.verbose {
        log::set_max_level(log::LevelFilter::Debug);
    } else {
        log::set_max_level(log::LevelFilter::Info);
    }

    // Simple console logger without regex dependency
    log::set_logger(&SimpleLogger).unwrap();

    // Create and run server
    let server = OnDemandHttpsServer::new(args).await?;
    server.run().await?;

    Ok(())
}
