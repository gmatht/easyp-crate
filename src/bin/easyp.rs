//! easyp - On-demand HTTPS server with ACME certificate management
//!
//! This example demonstrates a complete on-demand HTTPS server that:
//! - Accepts HTTPS connections using rustls Acceptor
//! - Validates that domains resolve to authorized IP addresses
//! - Dynamically fetches ACME certificates from Let's Encrypt
//! - Caches certificates for performance
//! - Handles both HTTP-01 and DNS-01 challenges
//!
//! Usage:
//!   cargo run --example easyp --features acme -- --help

use std::collections::{BTreeMap, HashMap};
use std::io::{Read, Write};
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_rustls::TlsAcceptor;
use tokio_rustls::rustls::ServerConfig as TokioServerConfig;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::time::Duration;

use lexopt::prelude::*;
use rustls::server::{Acceptor, ResolvesServerCert};
use rustls::{ServerConfig, ServerConnection};
use rustls::sign::CertifiedKey;

// Simple logger without regex dependency
struct SimpleLogger;

impl log::Log for SimpleLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.level() <= log::max_level()
    }

    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            println!("{}: {}", record.level(), record.args());
        }
    }

    fn flush(&self) {}
}

#[cfg(feature = "acme")]
use rustls_acme::{AcmeClient, OnDemandCertResolver, DnsValidator};
use rustls_acme::{AcmeConfig, ChallengeType};

// Import our modules
#[path = "../cgi_env.rs"]
mod cgi_env;
#[path = "../modules/secure_file_server_module.rs"]
mod secure_file_server_module;
use secure_file_server_module::{SecureFileServer, SecurityConfig};

#[path = "../modules/file_handler.rs"]
mod file_handler;
use file_handler::{
    extract_domain_from_host_header
};

// HTTP Multi-Version Support modules
#[path = "../modules/http_version.rs"]
mod http_version;
#[path = "../modules/http_response.rs"]
mod http_response;
#[path = "../modules/connection_policy.rs"]
mod connection_policy;
#[path = "../modules/file_cache.rs"]
mod file_cache;

use http_version::HttpVersion;
use http_response::HttpResponse;
use connection_policy::ConnectionPolicy;

// Extension system - auto-generated by build.rs
#[cfg(feature = "extensions")]
include!(concat!(env!("OUT_DIR"), "/generated_extensions.rs"));

// Debug: Check if extensions feature is enabled
#[cfg(feature = "extensions")]
fn debug_extensions_enabled() {
    println!("DEBUG: Extensions feature is ENABLED");
}

#[cfg(not(feature = "extensions"))]
fn debug_extensions_enabled() {
    println!("DEBUG: Extensions feature is DISABLED");
}

// Always define ExtensionRegistry - either from generated code or as placeholder
#[cfg(not(feature = "extensions"))]
#[derive(Clone)]
struct ExtensionRegistry;

#[cfg(not(feature = "extensions"))]
impl ExtensionRegistry {
    fn new() -> Self {
        Self
    }

    fn process_html(&self, html: &str, _url: &str) -> String {
        html.to_string()
    }

    fn is_valid_admin_key(&self, _key: &str) -> bool {
        false
    }

    async fn process_admin_request(&self, _path: &str, _query: &str, _body: &str, _headers: &std::collections::HashMap<String, String>) -> Result<String, Box<dyn std::error::Error>> {
        Ok(r#"{"error": "Admin features not available"}"#.to_string())
    }
}

#[derive(Clone)]
struct Args {
    domains: Vec<String>,
    http_port: u16,
    https_port: u16,
    email: Option<String>,
    staging: bool,
    over_9000: bool,
    test_client: Option<String>,
    test_root: String,
    root: String,
    allowed_ips: Option<String>,
    cache_dir: String,
    verbose: bool,
    test_mode: bool,
    restore_backup: bool,
    bogus_domain: Option<String>,
    port: u16,
    acme_directory: String,
    acme_email: Option<String>,
    challenge_type: String,
    admin_urls: bool,
}

impl Args {
    fn parse() -> Result<Self, Box<dyn std::error::Error>> {
        let mut domains = Vec::new();
        let mut http_port = 80;
        let mut https_port = 443;
        let mut email = None;
        let mut staging = false;
        let mut over_9000 = false;
        let mut test_client = None;
        let mut test_root = "test_root".to_string();
        let mut root = "/var/www/html".to_string();
        let mut allowed_ips = None;
        let mut cache_dir = "/var/lib/easyp/certs".to_string();
        let mut verbose = false;
        let mut test_mode = false;
        let mut restore_backup = false;
        let mut bogus_domain = None;
        let mut port = 443;
        let mut acme_directory = "https://acme-v02.api.letsencrypt.org/directory".to_string();
        let mut acme_email = None;
        let mut challenge_type = "http01".to_string();
        let mut admin_urls = false;

        let mut parser = lexopt::Parser::from_env();
        while let Some(arg) = parser.next()? {
            match arg {
                Value(val) => {
                    domains.push(val.to_string_lossy().to_string());
                }
                Short('p') | Long("port") => {
                    port = parser.value()?.parse()?;
                }
                Long("http-port") => {
                    http_port = parser.value()?.parse()?;
                }
                Long("https-port") => {
                    https_port = parser.value()?.parse()?;
                }
                Long("email") => {
                    email = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("staging") => {
                    staging = true;
                }
                Long("over-9000") => {
                    over_9000 = true;
                }
                Long("test-client") => {
                    test_client = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("test-root") => {
                    test_root = parser.value()?.to_string_lossy().to_string();
                }
                Long("root") => {
                    root = parser.value()?.to_string_lossy().to_string();
                }
                Long("allowed-ips") => {
                    allowed_ips = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("cache-dir") => {
                    cache_dir = parser.value()?.to_string_lossy().to_string();
                }
                Short('v') | Long("verbose") => {
                    verbose = true;
                }
                Long("test-mode") => {
                    test_mode = true;
                }
                Long("restore-backup") => {
                    restore_backup = true;
                }
                Long("bogus-domain") => {
                    bogus_domain = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("acme-directory") => {
                    acme_directory = parser.value()?.to_string_lossy().to_string();
                }
                Long("acme-email") => {
                    acme_email = Some(parser.value()?.to_string_lossy().to_string());
                }
                Long("challenge-type") => {
                    challenge_type = parser.value()?.to_string_lossy().to_string();
                }
                Long("admin-urls") => {
                    admin_urls = true;
                }
                Long("help") => {
                    println!("easyp - On-demand HTTPS server with ACME certificate management");
                    println!();
                    println!("USAGE:");
                    println!("    easyp [OPTIONS] [DOMAINS]...");
                    println!();
                    println!("ARGS:");
                    println!("    [DOMAINS]...    Optional domains to serve (e.g., example.com, *.example.com)");
                    println!("                   If not specified, domains will be discovered on-demand from certificate requests");
                    println!();
                    println!("OPTIONS:");
                    println!("    -p, --port <PORT>                    Port to listen on (legacy, use --https-port instead) [default: 443]");
                    println!("        --http-port <PORT>               HTTP port [default: 80]");
                    println!("        --https-port <PORT>              HTTPS port [default: 443]");
                    println!("        --email <EMAIL>                  Email for ACME certificate registration");
                    println!("        --staging                         Use Let's Encrypt staging environment");
                    println!("        --over-9000                       Add 9000 to default port numbers (HTTP: 9080, HTTPS: 9443)");
                    println!("        --test-client <CLIENT>            Test client binary to run when server is ready");
                    println!("        --test-root <ROOT>                Test root directory for integration tests [default: test_root]");
                    println!("        --root <ROOT>                     Document root directory [default: /var/www/html]");
                    println!("        --allowed-ips <IPS>               Allowed IP addresses for on-demand certificate requests (comma-separated)");
                    println!("        --cache-dir <DIR>                 Cache directory for ACME certificates [default: /var/lib/easyp/certs]");
                    println!("    -v, --verbose                        Enable verbose logging");
                    println!("        --test-mode                       Test mode (use self-signed certificates)");
                    println!("        --restore-backup                  Restore ACME certificates from backup before starting");
                    println!("        --bogus-domain <DOMAIN>           Bogus domain to use for ACME requests (workaround for rate limits)");
                    println!("        --acme-directory <URL>            ACME directory URL (legacy, use --staging instead) [default: https://acme-v02.api.letsencrypt.org/directory]");
                    println!("        --acme-email <EMAIL>              Email address for ACME account (legacy, use --email instead)");
                    println!("        --challenge-type <TYPE>           Challenge type (http01 or dns01) [default: http01]");
                    println!("        --admin-urls                      Print admin URLs for all domains and admin keys, then exit");
                    println!("        --help                            Print help information");
                    std::process::exit(0);
                }
                _ => return Err(format!("unexpected argument: {:?}", arg).into()),
            }
        }

        // Domains are optional for on-demand HTTPS server
        // The server can discover domains dynamically from certificate requests

        Ok(Args {
            domains,
            http_port,
            https_port,
            email,
            staging,
            over_9000,
            test_client,
            test_root,
            root,
            allowed_ips,
            cache_dir,
            verbose,
            test_mode,
            restore_backup,
            bogus_domain,
            port,
            acme_directory,
            acme_email,
            challenge_type,
            admin_urls,
        })
    }
}

/// Test certificate resolver that loads or creates a self-signed certificate on startup
/// and never creates new certificates after that
#[derive(Debug)]
struct TestCertResolver {
    allowed_ips: Vec<IpAddr>,
    cert_cache: Arc<Mutex<HashMap<String, CertifiedKey>>>,
    default_cert: Option<CertifiedKey>,
}

impl TestCertResolver {
    fn new(allowed_ips: Vec<IpAddr>) -> Result<Self, Box<dyn std::error::Error>> {
        println!("üîç Initializing TestCertResolver with self-signed certificate...");

        // Try to load existing self-signed certificate
        let cert_path = "/var/lib/easyp/certs/localhost/fullchain.pem";
        let key_path = "/var/lib/easyp/certs/localhost/privkey.pem";

        let default_cert = if std::path::Path::new(cert_path).exists() && std::path::Path::new(key_path).exists() {
            println!("üîç Loading existing self-signed certificate from {}", cert_path);
            match Self::load_certificate_from_files(cert_path, key_path) {
                Ok(cert) => {
                    println!("‚úÖ Successfully loaded existing self-signed certificate");
                    Some(cert)
                }
                Err(e) => {
                    println!("‚ö†Ô∏è  Failed to load existing certificate: {}, will create new one", e);
                    None
                }
            }
        } else {
            println!("üîç No existing certificate found, creating new self-signed certificate...");
            None
        };

        let default_cert = match default_cert {
            Some(cert) => Some(cert),
            None => {
                println!("üîç Generating new self-signed certificate for localhost...");
                match Self::generate_self_signed_certificate("localhost") {
                    Ok(cert) => {
                        println!("‚úÖ Successfully generated new self-signed certificate");
                        Some(cert)
                    }
                    Err(e) => {
                        println!("‚ùå Failed to generate self-signed certificate: {}", e);
                        return Err(e);
                    }
                }
            }
        };

        Ok(Self {
            allowed_ips,
            cert_cache: Arc::new(Mutex::new(HashMap::new())),
            default_cert,
        })
    }

    fn load_certificate_from_files(cert_path: &str, key_path: &str) -> Result<CertifiedKey, Box<dyn std::error::Error>> {
        use rustls_pemfile::{certs, pkcs8_private_keys};
        use std::io::BufReader;

        let cert_file = std::fs::File::open(cert_path)?;
        let mut cert_reader = BufReader::new(cert_file);
        let cert_chain: Result<Vec<_>, _> = certs(&mut cert_reader)
            .into_iter()
            .map(|cert| cert.map(rustls::pki_types::CertificateDer::from))
            .collect();
        let cert_chain = cert_chain?;

        let key_file = std::fs::File::open(key_path)?;
        let mut key_reader = BufReader::new(key_file);
        let keys: Result<Vec<_>, _> = pkcs8_private_keys(&mut key_reader).collect();
        let mut keys = keys?;

        if keys.is_empty() {
            return Err("No private key found in key file".into());
        }

        let key = rustls::pki_types::PrivateKeyDer::Pkcs8(
            rustls::pki_types::PrivatePkcs8KeyDer::from(keys.remove(0))
        );

        // Create the CertifiedKey using the correct API
        let certified_key = rustls::sign::CertifiedKey::from_der(
            cert_chain.into(),
            key,
            &rustls::crypto::ring::default_provider(),
        ).map_err(|e| format!("Failed to create CertifiedKey: {}", e))?;

        Ok(certified_key)
    }

    fn generate_self_signed_certificate(domain: &str) -> Result<CertifiedKey, Box<dyn std::error::Error>> {
        use rcgen::{CertificateParams, KeyPair, SanType, PKCS_RSA_SHA256};

        // Create certificate directory
        let cert_dir = format!("/var/lib/easyp/certs/{}", domain);
        std::fs::create_dir_all(&cert_dir)?;

        // Generate RSA key pair for better Safari 6-8 compatibility
        // Safari 6-8 has better support for RSA certificates than ECDSA
        let key_pair = KeyPair::generate_for(&PKCS_RSA_SHA256)?;

        // Create certificate parameters
        let mut params = CertificateParams::new(vec![domain.to_string()])?;

        // Add Subject Alternative Names for better compatibility
        params.subject_alt_names = vec![
            SanType::DnsName(rcgen::string::Ia5String::try_from(domain)?),
            SanType::DnsName(rcgen::string::Ia5String::try_from("localhost")?),
            SanType::IpAddress(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),
            SanType::IpAddress(std::net::IpAddr::V6(std::net::Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1))),
        ];

        // Set additional parameters for Safari compatibility
        params.distinguished_name = rcgen::DistinguishedName::new();

        // Use SHA-256 signature algorithm for better Safari 6-8 compatibility
        // Safari 6-8 may not support SHA-384 or SHA-512 signatures
        // The algorithm is set when creating the KeyPair, not in params

        // Set key usage for TLS server authentication
        params.key_usages = vec![
            rcgen::KeyUsagePurpose::DigitalSignature,
            rcgen::KeyUsagePurpose::KeyEncipherment,
        ];

        // Set extended key usage for TLS server authentication
        params.extended_key_usages = vec![
            rcgen::ExtendedKeyUsagePurpose::ServerAuth,
        ];

        // Generate the certificate
        let cert = params.self_signed(&key_pair)?;

        // Get PEM-encoded certificate and private key
        let cert_pem = cert.pem();
        let key_pem = key_pair.serialize_pem();

        // Write fullchain.pem (same as cert.pem for self-signed)
        std::fs::write(format!("{}/fullchain.pem", cert_dir), &cert_pem)?;

        // Write privkey.pem
        std::fs::write(format!("{}/privkey.pem", cert_dir), &key_pem)?;

        // Set proper permissions
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&cert_dir)?.permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&cert_dir, perms)?;

            let mut key_perms = std::fs::metadata(format!("{}/privkey.pem", cert_dir))?.permissions();
            key_perms.set_mode(0o600);
            std::fs::set_permissions(format!("{}/privkey.pem", cert_dir), key_perms)?;
        }

        println!("‚úÖ Self-signed certificate generated for {} in {}", domain, cert_dir);

        // Convert to CertifiedKey format
        let cert_der = cert.der().to_vec();
        let key_der = key_pair.serialize_der();

        let cert_chain = vec![rustls::pki_types::CertificateDer::from(cert_der)];
        let key = rustls::pki_types::PrivateKeyDer::Pkcs8(
            rustls::pki_types::PrivatePkcs8KeyDer::from(key_der)
        );

        // Create the CertifiedKey using the correct API
        let certified_key = rustls::sign::CertifiedKey::from_der(
            cert_chain.into(),
            key,
            &rustls::crypto::ring::default_provider(),
        ).map_err(|e| format!("Failed to create CertifiedKey: {}", e))?;

        Ok(certified_key)
    }
}

impl ResolvesServerCert for TestCertResolver {
    fn resolve(&self, client_hello: &rustls::server::ClientHello<'_>) -> Result<rustls::sign::CertifiedSigner, rustls::Error> {
        let Some(server_name) = client_hello.server_name() else {
            // If no server name, use the default certificate
            if let Some(ref default_cert) = self.default_cert {
                return default_cert.signer(client_hello.signature_schemes())
                    .ok_or(rustls::Error::NoSuitableCertificate);
            }
            return Err(rustls::Error::NoSuitableCertificate);
        };

        let domain = server_name.as_ref();

        // Check cache first
        if let Ok(cache) = self.cert_cache.lock() {
            if let Some(certified_key) = cache.get(domain) {
                return certified_key.signer(client_hello.signature_schemes())
                    .ok_or(rustls::Error::NoSuitableCertificate);
            }
        }

        // For any domain, return the default self-signed certificate
        // This ensures we never create new certificates after startup
        if let Some(ref default_cert) = self.default_cert {
            // Just return the signer directly - no need to cache since we only have one cert
            return default_cert.signer(client_hello.signature_schemes())
                .ok_or(rustls::Error::NoSuitableCertificate);
        }

        println!("‚ùå No default certificate available for domain: {}", domain);
        Err(rustls::Error::NoSuitableCertificate)
    }
}

/// On-demand HTTPS server
struct OnDemandHttpsServer {
    http_listener: tokio::net::TcpListener,  // Port 80 for ACME challenges
    https_listener: tokio::net::TcpListener, // Port 443 for HTTPS traffic
    cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
    args: Args,
    http_challenges: Arc<Mutex<BTreeMap<String, String>>>, // token -> key_authorization
    #[cfg(feature = "acme")]
    acme_client: Option<Arc<AcmeClient>>, // Added for challenge storage
    allowed_ips: Vec<IpAddr>, // Store allowed IPs for display
    extension_registry: Arc<Mutex<ExtensionRegistry>>, // Extension system
    secure_file_server: SecureFileServer, // Secure file serving with security features
}

impl OnDemandHttpsServer {
    /// Create a new on-demand HTTPS server
    async fn new(args: Args) -> Result<Self, Box<dyn std::error::Error>> {
        // Apply --over-9000 option to port numbers
        let http_port = if args.over_9000 {
            args.http_port + 9000
        } else {
            args.http_port
        };

        let https_port = if args.over_9000 {
            args.https_port + 9000
        } else {
            args.https_port
        };

        // Use legacy --port argument if provided (overrides --https-port)
        let final_https_port = if args.port != 443 || args.over_9000 {
            args.port
        } else {
            https_port
        };

        // Create HTTP listener on specified port for ACME challenges
        let http_listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", http_port)).await?;

        // Create HTTPS listener on specified port for HTTPS traffic
        let https_listener = tokio::net::TcpListener::bind(format!("0.0.0.0:{}", final_https_port)).await?;

        // Look up www-data UID/GID dynamically (only on UNIX systems and when running as root)
        #[cfg(unix)]
        let (www_data_uid, www_data_gid) = if is_running_as_root() {
            get_www_data_uid_gid()?
        } else {
            (0, 0) // Use current user if not root
        };

        // Create secure file server with security features
        let document_root = if args.root.starts_with('/') {
            // Absolute path
            PathBuf::from(&args.root)
        } else {
            // Relative path - make it absolute
            std::env::current_dir()?.join(&args.root)
        };

        let secure_file_server = SecureFileServer::new(SecurityConfig {
            document_root,
            follow_symlinks: false, // Security: don't follow symlinks by default
            max_file_size: 10 * 1024 * 1024 * 1024 * 1024, // 10TB max file size
            allowed_extensions: vec![
/*
                // Web files
                "html".to_string(), "htm".to_string(), "css".to_string(),
                "js".to_string(), "json".to_string(),
                // Images
                "jpg".to_string(), "jpeg".to_string(), "png".to_string(),
                "gif".to_string(), "svg".to_string(), "webp".to_string(),
                "ico".to_string(),
                // WebAssembly
                "wasm".to_string(),
                // Documents
                "txt".to_string(), "pdf".to_string(),
                // Archives
                "zip".to_string(), "tar".to_string(), "gz".to_string(),
*/
            ],
            blocked_extensions: vec![
/*
                // Dangerous executables
                "exe".to_string(), "bat".to_string(), "cmd".to_string(),
                "com".to_string(), "pif".to_string(), "scr".to_string(),
                "vbs".to_string(), "jar".to_string(), "sh".to_string(),
*/
                // System files
                "htaccess".to_string(), "htpasswd".to_string(),
            ],
            #[cfg(unix)]
            drop_to_uid: if is_running_as_root() { Some(www_data_uid) } else { None },
            #[cfg(unix)]
            drop_to_gid: if is_running_as_root() { Some(www_data_gid) } else { None },
            #[cfg(not(unix))]
            drop_to_uid: None,
            #[cfg(not(unix))]
            drop_to_gid: None,
            keep_alive_timeout: Duration::from_secs(5),
            keep_alive_max_requests: 100,
            minimum_http_version: HttpVersion::Http09,
        });

               #[cfg(target_os = "redox")]
               let allowed_ips = Vec::new(); //STUB
               // Parse allowed IP addresses or auto-detect
               #[cfg(not(target_os = "redox"))]
               let allowed_ips = if let Some(ips_str) = &args.allowed_ips {
                   parse_allowed_ips(ips_str)?
               } else {
                   println!("[{}] No allowed IPs specified, auto-detecting server IPs...",
                 std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs());
                   let detected_ips = detect_server_ips().unwrap_or_else(|e| {
                       println!("Warning: Could not detect server IPs ({}), returning empty list", e);
                       Vec::new()
                   });

                   if detected_ips.is_empty() {
                       eprintln!("Error: No valid IP addresses detected. Please specify --allowed-ips explicitly.");
                       eprintln!("This is required for security - localhost addresses are not allowed for ACME requests.");
                       std::process::exit(1);
                   }

                   detected_ips
               };

               // Create certificate resolver with real ACME integration
               #[cfg(feature = "acme")]
               let (cert_resolver, acme_client) = if args.test_mode {
                   // In test mode, use staging ACME servers for real certificates
                   let directory_url = "https://acme-staging-v02.api.letsencrypt.org/directory".to_string();

                   // Determine email (prefer new --email over legacy --acme-email)
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (use staging subdirectory for test mode)
                   let cache_dir = Some(format!("{}/staging", args.cache_dir));

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir,
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01("".to_string(), "".to_string()),
                       is_staging: true, // Always staging in test mode
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);
                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               } else {
                   // Determine ACME directory URL
                   let directory_url = if args.staging {
                       "https://acme-staging-v02.api.letsencrypt.org/directory".to_string()
                   } else {
                       args.acme_directory.clone()
                   };

                   // Determine email (prefer new --email over legacy --acme-email)
                   // If no email is provided, the ACME client will generate webmaster@domain for each domain
                   let email = args.email.clone()
                       .or(args.acme_email.clone())
                       .unwrap_or_default();

                   // Determine cache directory (use staging or production subdirectory based on staging flag)
                   let cache_dir = if args.staging || args.acme_directory.contains("staging") || args.acme_directory.contains("stg") {
                       Some(format!("{}/staging", args.cache_dir))
                   } else {
                       Some(format!("{}/production", args.cache_dir))
                   };

                   let acme_config = AcmeConfig {
                       directory_url,
                       email,
                       allowed_ips: allowed_ips.clone(),
                       cache_dir: cache_dir.clone(),
                       renewal_threshold_days: 30,
                       challenge_type: ChallengeType::Http01("".to_string(), "".to_string()),
                       is_staging: args.staging || args.acme_directory.contains("staging") || args.acme_directory.contains("stg"),
                       bogus_domain: args.bogus_domain.clone(),
                   };

                   let acme_client = AcmeClient::new(acme_config);

                   // Restore from backup if requested
                   if args.restore_backup {
                       println!("üîÑ Restoring ACME certificates from backup...");
                       let acme_persist_dir = format!("{}/acme_lib", cache_dir.as_ref().unwrap());
                       if let Err(e) = acme_client.restore_acme_data(&acme_persist_dir) {
                           println!("‚ö†Ô∏è  Failed to restore from backup: {}", e);
                       } else {
                           println!("‚úÖ ACME certificates restored from backup");
                       }
                   }

                   // Note: ACME account will be initialized per-domain when certificates are requested

                   let acme_client = Arc::new(acme_client);
                   let dns_validator = Arc::new(DnsValidator::new(allowed_ips.clone())?);

                   let cert_resolver = Arc::new(OnDemandCertResolver::new(
                       acme_client.clone(),
                       dns_validator,
                       None, // No fallback resolver
                       1000, // Max cache size
                       Duration::from_secs(30 * 24 * 60 * 60), // 30 days renewal threshold
                   )?);

                   (cert_resolver as Arc<dyn ResolvesServerCert + Send + Sync>, Some(acme_client))
               };

               #[cfg(not(feature = "acme"))]
               let (cert_resolver, acme_client) = {
                   // Fallback to test resolver if ACME feature not enabled
                   (Arc::new(TestCertResolver::new(allowed_ips)?), None)
               };

               // Ensure certificate cache directory has proper ownership before dropping privileges
               #[cfg(unix)]
               if let Err(e) = ensure_cert_cache_permissions(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set certificate cache permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }

               // Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
               #[cfg(unix)]
               if let Err(e) = ensure_tmp_acme_permissions(www_data_uid, www_data_gid) {
                   println!("Warning: Failed to set /tmp/acme_certs permissions: {}", e);
                   // Continue anyway - this is not a fatal error
               }

               // Ensure ACME cache directory is properly configured and accessible
               println!("ACME cache directory: {}", args.cache_dir);
               #[cfg(unix)]
               if let Err(e) = ensure_acme_cache_directory(&args.cache_dir, www_data_uid, www_data_gid) {
                   println!("Error: Failed to set up ACME cache directory: {}", e);
                   return Err(format!("ACME cache directory setup failed: {}", e).into());
               }

               // Domain request logger removed - was unused dead code

                // Initialize root extensions and admin system before dropping privileges
                #[cfg(feature = "extensions")]
                let extension_registry = {
                    println!("Initializing root extensions and admin system...");
                    let mut registry = ExtensionRegistry::new();

                    // Load existing admin keys from file
                    if let Err(e) = registry.load_existing_admin_keys() {
                        println!("Warning: Failed to load existing admin keys: {}", e);
                    }

                    // Generate missing admin keys and append to file
                    if let Err(e) = registry.generate_missing_admin_keys() {
                        println!("Warning: Failed to generate missing admin keys: {}", e);
                    }

                    // Ensure admin file has correct permissions
                    if let Err(e) = registry.ensure_admin_file_permissions() {
                        println!("Warning: Failed to set admin file permissions: {}", e);
                    }

                    // Initialize root extensions
                    if let Err(e) = registry.initialize_root_extensions() {
                        println!("Warning: Failed to initialize root extensions: {}", e);
                    }

                    Arc::new(Mutex::new(registry))
                };

                #[cfg(not(feature = "extensions"))]
                let extension_registry = Arc::new(Mutex::new(ExtensionRegistry::new()));

               // Drop privileges to unprivileged user after binding to privileged ports (only if running as root)
               if is_running_as_root() {
                   if let Err(e) = secure_file_server.drop_privileges() {
                       println!("Warning: Failed to drop privileges: {}", e);
                       // Continue anyway - this is not a fatal error
                   } else {
                   // Verify that privileges were dropped successfully
                   match std::process::Command::new("whoami").output() {
                       Ok(output) => {
                           if output.status.success() {
                               let username = String::from_utf8_lossy(&output.stdout).trim().to_string();
                               println!("Server now running as user: {}", username);
                           } else {
                               println!("Warning: Could not determine current user after privilege drop");
                           }
                       }
                       Err(_) => {
                           println!("Warning: Could not determine current user after privilege drop");
                       }
                   }
               }
               } else {
                   println!("Not running as root, skipping privilege dropping");
               }


               // Use shared challenge storage from ACME client instead of separate storage
               let http_challenges = if let Some(ref acme_client) = acme_client {
                   // Convert the ACME client's challenge storage to the format expected by HTTP server
                   Arc::new(Mutex::new(BTreeMap::new())) // We'll access challenges directly from ACME client
               } else {
                   Arc::new(Mutex::new(BTreeMap::new()))
               };

               Ok(Self {
                   http_listener,
                   https_listener,
                   cert_resolver,
                   args,
                   http_challenges,
                   acme_client,
                   allowed_ips,
                   extension_registry,
                   secure_file_server,
               })
    }

    /// Run the server
    async fn run(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Calculate actual ports (including --over-9000 effect)
        let http_port = if self.args.over_9000 {
            self.args.http_port + 9000
        } else {
            self.args.http_port
        };

        let https_port = if self.args.over_9000 {
            self.args.https_port + 9000
        } else {
            self.args.https_port
        };

        let final_https_port = if self.args.port != 443 || self.args.over_9000 {
            self.args.port
        } else {
            https_port
        };

        println!("Starting easyp on-demand HTTPS server");
        println!("HTTP listener on port {} (for ACME challenges)", http_port);
        println!("HTTPS listener on port {} (for HTTPS traffic)", final_https_port);
        println!("Allowed IPs: {:?}", self.allowed_ips);
        println!("ACME Directory: {}", if self.args.staging { "https://acme-staging-v02.api.letsencrypt.org/directory" } else { &self.args.acme_directory });
        println!("Challenge Type: {}", self.args.challenge_type);
        println!("Test Mode: {}", self.args.test_mode);
        if !self.args.domains.is_empty() {
            println!("Domains: {:?}", self.args.domains);
        }
        if let Some(ref email) = self.args.email.clone().or(self.args.acme_email.clone()) {
            println!("Email: {}", email);
        }
        println!("Document Root: {}", self.args.root);
        println!("Cache Directory: {}", self.args.cache_dir);

        // Run test client if specified
        if let Some(ref test_client) = self.args.test_client {
            let test_client = test_client.clone();
            println!("Running test client: {}", test_client);
            std::thread::spawn(move || {
                let output = std::process::Command::new(&test_client)
                    .output()
                    .expect("Failed to execute test client");
                println!("Test client output: {}", String::from_utf8_lossy(&output.stdout));
                if !output.stderr.is_empty() {
                    eprintln!("Test client stderr: {}", String::from_utf8_lossy(&output.stderr));
                }
            });
        }

        let mut connections: Vec<ServerConnection> = Vec::new();

        println!("üîç Starting async server loop");

        // No more polling! The ACME client and HTTP server now share the same challenge storage
        // Challenges are automatically available to the HTTP server when created by the ACME client

        println!("üîç Starting main server loop - listening on HTTP port {} and HTTPS port {}", http_port, final_https_port);
        loop {
        tokio::select! {
                // Accept HTTP connections (port 80) for ACME challenges
                result = self.http_listener.accept() => {
                    match result {
                        Ok((stream, addr)) => {
                            println!("üîç New HTTP connection from {} (ACME challenge)", addr);

                            // Handle HTTP connection for ACME challenges and file serving
                            let acme_client = self.acme_client.clone();
                            let http_challenges = self.http_challenges.clone();
                            let secure_file_server = self.secure_file_server.clone();
                            let extension_registry = self.extension_registry.clone();

                    tokio::task::spawn_blocking(move || {
                        let rt = tokio::runtime::Handle::current();
                        rt.block_on(async {
                            match Self::handle_http_connection(stream, acme_client, http_challenges, secure_file_server, extension_registry).await {
                                Ok(()) => {},
                                Err(e) => {
                                    let error_msg = format!("{}", e);
                                    eprintln!("HTTP connection error: {}", error_msg);
                                }
                            }
                        })
                    });
                        }
                        Err(e) => {
                            eprintln!("‚ùå HTTP accept error: {}", e);
                        }
                    }
                }

                // Accept HTTPS connections (port 443) for HTTPS traffic
                result = self.https_listener.accept() => {
                    println!("üîç HTTPS accept() returned: {:?}", result);
                    match result {
                        Ok((stream, addr)) => {
                            println!("üîç New HTTPS connection from {}", addr);

                            // Handle HTTPS connection
                            let cert_resolver = self.cert_resolver.clone();
                            let args = self.args.clone();
                            let acme_client = self.acme_client.clone();
                            let http_challenges = self.http_challenges.clone();
                            let extension_registry = self.extension_registry.clone();
                            let secure_file_server = self.secure_file_server.clone();

                            tokio::spawn(async move {
                                if let Err(e) = Self::handle_connection_static(stream, cert_resolver, args, extension_registry, http_challenges, secure_file_server).await {
                                    eprintln!("HTTPS connection error: {}", e);
                                }
                            });
                        }
                        Err(e) => {
                            eprintln!("‚ùå HTTPS accept error: {}", e);
                        }
                    }
            }
        }

            // Process existing connections
            connections.retain(|conn| {
                // In a real implementation, you'd process the connection here
                // For this example, we just remove completed connections
                false
            });

            // Small delay to prevent busy waiting
            std::thread::sleep(Duration::from_millis(10));
        }
    }

    /// Handle HTTP connection (port 80) for ACME challenges and file serving
    async fn handle_http_connection(
        mut stream: tokio::net::TcpStream,
        #[cfg(feature = "acme")]
        acme_client: Option<Arc<AcmeClient>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Create connection policy for Keep-Alive decisions
        let connection_policy = ConnectionPolicy::default();
        let mut request_count = 0;

        // Keep-Alive loop: handle multiple requests on the same connection
        loop {
        // Read HTTP request
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        // Read data in a loop to handle partial reads
        loop {
            match stream.read(&mut buffer[total_read..]).await {
                    Ok(0) => {
                        // Connection closed by client
                        println!("DEBUG: HTTP connection closed by client");
                        return Ok(());
                    }
                Ok(n) => {
                    total_read += n;
                    if total_read >= buffer.len() {
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        if request_str.contains("\r\n\r\n") {
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        }

        // Parse HTTP request
        let request = String::from_utf8_lossy(&buffer[..total_read]);
        let lines: Vec<&str> = request.lines().collect();

        // Parse HTTP version and connection header from request
        let (http_version, connection_header) = ConnectionPolicy::parse_request_info(&request);
        request_count += 1;

        // Determine if we should keep the connection alive
        let should_keep_alive = connection_policy.should_keep_alive(
            &http_version,
            connection_header.as_deref(),
            0, // We don't have response size here, but it's not critical for the decision
            request_count,
        );

        // Extract domain from Host header
        let domain = extract_domain_from_host_header(&request);

        println!("DEBUG: HTTP connection - total_read: {}", total_read);
        println!("DEBUG: HTTP request (first 200 bytes): {}", &request[..std::cmp::min(200, request.len())]);

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

            // Handle HTTP-01 ACME challenges
            if first_line.starts_with("GET /.well-known/acme-challenge/") {
                return Self::handle_acme_challenge_http(stream, first_line, &acme_client, &http_challenges).await;
            }
        }

        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                let path_with_query = &first_line[path_start + 1..];
                // Find the end of the path (either next space or query string)
                let path_end = if let Some(query_start) = path_with_query.find('?') {
                    query_start
                } else if let Some(space_pos) = path_with_query.find(' ') {
                    space_pos
                } else {
                    path_with_query.len()
                };
                &path_with_query[..path_end]
            } else {
                "/"
            }
        } else {
            "/"
        };
        println!("DEBUG: Full request: {}", request);

        // Check for bin extension requests (CGI-like)
        if request_path.starts_with("/cgi-bin/") {
            // Extract query string from the original request line
            let query_string = if let Some(first_line) = lines.first() {
                if let Some(path_start) = first_line.find(' ') {
                    let path_with_query = &first_line[path_start + 1..];
                    if let Some(query_start) = path_with_query.find('?') {
                        let query_part = &path_with_query[query_start + 1..];
                        // Find the end of the query string (next space)
                        if let Some(space_pos) = query_part.find(' ') {
                            &query_part[..space_pos]
                        } else {
                            query_part
                        }
                    } else {
                        ""
                    }
                } else {
                    ""
                }
            } else {
                ""
            };

            // Extract the path without query string (already done above)
            let bin_path = request_path;

            // Parse headers
            let mut headers = std::collections::HashMap::new();
            for line in &lines[1..] {
                if let Some(colon_pos) = line.find(':') {
                    let header_name = line[..colon_pos].trim().to_lowercase();
                    let header_value = line[colon_pos + 1..].trim().to_string();
                    headers.insert(header_name, header_value);
                }
            }

            // Handle bin extension request
            let response = {
                let registry = extension_registry.lock().unwrap();
                registry.handle_bin_request(bin_path, "GET", query_string, &headers)
            };

            match response {
                Ok(response) => {
                    stream.write_all(response.as_bytes()).await?;
                    stream.flush().await?;
                    return Ok(());
                }
                Err(e) => {
                    let error_msg = format!("Error: {}", e);

                    // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTP)
                    let mut response = HttpResponse::internal_server_error(error_msg.as_bytes().to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTP
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                    return Ok(());
                }
            }
        }

        // Check for admin extension requests
        #[cfg(feature = "extensions")]
        {
            println!("DEBUG: Checking for admin request with path: {}", request_path);
            // Use dynamic admin path checking instead of hardcoded paths
            let is_admin_request = {
                let registry = extension_registry.lock().unwrap();
                registry.is_admin_path(request_path)
            };
            println!("DEBUG: Admin request check result: {}", is_admin_request);
            if is_admin_request {
                println!("DEBUG: Admin request detected for path: {}", request_path);

                // Extract HTTP method from the first line
                let http_method = if let Some(first_line) = lines.first() {
                    first_line.split_whitespace().next().unwrap_or("GET")
                } else {
                    "GET"
                };
                println!("DEBUG: HTTP method: {}", http_method);

                // Extract query string from the request
                let query_string = if let Some(query_start) = request_path.find('?') {
                    &request_path[query_start + 1..]
                } else {
                    ""
                };

                // Extract the path without query string
                let admin_path = if let Some(query_start) = request_path.find('?') {
                    &request_path[..query_start]
                } else {
                    request_path
                };

                // Parse headers
                let mut headers = std::collections::HashMap::new();
                let mut body = String::new();
                let mut in_body = false;

                for line in &lines[1..] {
                    if in_body {
                        body.push_str(line);
                        body.push('\n');
                    } else if line.is_empty() {
                        in_body = true; // Empty line indicates start of body
                    } else if let Some(colon_pos) = line.find(':') {
                        let header_name = line[..colon_pos].trim().to_lowercase();
                        let header_value = line[colon_pos + 1..].trim().to_string();
                        headers.insert(header_name, header_value);
                    }
                }

                // Remove trailing newline from body
                if body.ends_with('\n') {
                    body.pop();
                }

                // Handle admin extension request
                let admin_response = extension_registry.lock().unwrap().process_admin_request(admin_path, http_method, query_string, &body, &headers);
                match admin_response {
                    Ok(response) => {
                        stream.write_all(response.as_bytes()).await?;
                        stream.flush().await?;
                        return Ok(());
                    }
                    Err(e) => {
                        let error_msg = format!("Error: {}", e);

                        // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTP)
                        let mut response = HttpResponse::internal_server_error(error_msg.as_bytes().to_vec());
                        response.set_content_type("text/plain");
                        response.set_content_length();

                        let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTP
                        stream.write_all(&response_bytes).await?;
                        stream.flush().await?;
                        return Ok(());
                    }
                }
            }
        }

        println!("Requested path: {}", request_path);

        // Try to serve the requested file using secure file server with caching support
        let serve_result = secure_file_server.serve_file_with_domain_and_caching(
            request_path,
            domain.as_deref(),
            &request,
            &http_version,
            should_keep_alive
        );
        match serve_result {
            Ok(Some(response_bytes)) => {
                // This is a complete HTTP response (with caching headers)
                // Check if this is HTML content that needs extension processing
                let final_response_bytes = if let Ok(response_string) = String::from_utf8(response_bytes.clone()) {
                    println!("DEBUG: Response string length: {}", response_string.len());
                    println!("DEBUG: Response contains 'text/html': {}", response_string.contains("text/html"));
                    if response_string.contains("text/html") {
                        // Check if the HTML body contains #EXTEND: directives
                        if let Some(body_start) = response_string.find("\r\n\r\n") {
                            let body = &response_string[body_start + 4..];
                            println!("DEBUG: Body length: {}", body.len());
                            println!("DEBUG: Body contains '#EXTEND:': {}", body.contains("#EXTEND:"));
                            if body.contains("#EXTEND:") {
                                println!("DEBUG: Found #EXTEND: directive in HTML body, checking for constant extensions...");

                                // Check if this page only contains constant extensions
                                let has_constant_extensions_only = check_constant_extensions_only(body);

                                if has_constant_extensions_only {
                                    println!("DEBUG: Only constant extensions found, processing without breaking cache...");
                                    // Process extensions but keep the original cache headers
                                    #[cfg(feature = "extensions")]
                                    {
                                        let processed_html = extension_registry.lock().unwrap().process_html(body, request_path);
                                        // Reconstruct response but preserve original cache headers
                                        let headers = &response_string[..body_start + 4];
                                        let new_content_length = processed_html.len();
                                        // Update Content-Length header but keep cache headers intact
                                        let updated_headers = headers
                                            .lines()
                                            .map(|line| {
                                                if line.starts_with("Content-Length:") {
                                                    format!("Content-Length: {}", new_content_length)
                                                } else {
                                                    line.to_string()
                                                }
                                            })
                                            .collect::<Vec<String>>()
                                            .join("\r\n");
                                        format!("{}\r\n{}", updated_headers, processed_html).into_bytes()
                                    }
                                    #[cfg(not(feature = "extensions"))]
                                    {
                                        response_bytes
                                    }
                                } else {
                                    println!("DEBUG: Dynamic extensions found, processing with no-cache headers...");
                                    // Process extensions and add no-cache headers for dynamic content
                                    #[cfg(feature = "extensions")]
                                    {
                                        let processed_html = extension_registry.lock().unwrap().process_html(body, request_path);
                                        // Reconstruct response with no-cache headers
                                        let headers = &response_string[..body_start + 4];
                                        let new_content_length = processed_html.len();
                                        // Update headers and add no-cache
                                        let updated_headers = headers
                                            .lines()
                                            .map(|line| {
                                                if line.starts_with("Content-Length:") {
                                                    format!("Content-Length: {}", new_content_length)
                                                } else if line.starts_with("Cache-Control:") {
                                                    "Cache-Control: no-cache, no-store, must-revalidate".to_string()
                                                } else {
                                                    line.to_string()
                                                }
                                            })
                                            .collect::<Vec<String>>()
                                            .join("\r\n");
                                        format!("{}\r\n{}", updated_headers, processed_html).into_bytes()
                                    }
                                    #[cfg(not(feature = "extensions"))]
                                    {
                                        response_bytes
                                    }
                                }
                            } else {
                                response_bytes
                            }
                        } else {
                            response_bytes
                        }
                    } else {
                        response_bytes
                    }
                } else {
                    response_bytes
                };

                stream.write_all(&final_response_bytes).await?;
                    stream.flush().await?;
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                } else {
                    // File not found, send 404 for non-root requests
                    let mut response = HttpResponse::not_found(b"Not Found".to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
        stream.flush().await?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                let error_msg = format!("{}", e);
                println!("Request denied for {}: {}", request_path, error_msg);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page("localhost");
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                } else {
                    // Send 404 for non-root requests with security errors
                    let mut response = HttpResponse::not_found(b"Not Found".to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&http_version, should_keep_alive);
                    stream.write_all(&response_bytes).await?;
                    stream.flush().await?;
                }
            }
        }

        // Check if we should keep the connection alive for the next request
        if !should_keep_alive {
            println!("DEBUG: Closing HTTP connection after {} requests (version: {})",
                request_count, http_version);
            break; // Exit the Keep-Alive loop
        }

        println!("DEBUG: Keeping HTTP connection alive for next request (version: {})",
            http_version);
        }

        Ok(())
    }

    /// Handle a single HTTPS connection (static version for threading)
    async fn handle_connection_static(
        stream: tokio::net::TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç Starting HTTPS connection handling");

        // Use the new async HTTPS handler
        Self::handle_https_connection_async(
            stream,
                cert_resolver,
                args,
                extension_registry,
                http_challenges,
                secure_file_server,
        ).await
    }

    /// Handle HTTPS connection using async tokio-rustls (for large file support)
    async fn handle_https_connection_async(
        stream: tokio::net::TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç Starting async HTTPS connection handling");

        // Create server config with our certificate resolver
        let server_config = TokioServerConfig::builder_with_provider(
            rustls::crypto::ring::default_provider().into()
        )
        .with_no_client_auth()
        .with_cert_resolver(cert_resolver)?;

        // Create tokio-rustls acceptor
        let acceptor = TlsAcceptor::from(Arc::new(server_config));

        // Perform TLS handshake
        let mut tls_stream = acceptor.accept(stream).await?;
        println!("üîç TLS handshake completed");

        // Handle the connection with Keep-Alive support
        let mut connection_policy = ConnectionPolicy::new(100, 300);
        let mut request_count = 0;

        loop {
            request_count += 1;
            println!("üîç Processing async HTTPS request {} for domain", request_count);

            // Process the request and get parsed version/connection info
            let (http_version, connection_header) = Self::process_https_request_async(
                &mut tls_stream,
                &extension_registry,
                &http_challenges,
                &secure_file_server,
            ).await?;

            // Determine if we should keep the connection alive
            let should_keep_alive = connection_policy.should_keep_alive(
                &http_version,
                connection_header.as_deref(),
                0, // We don't have response size here, but it's not critical for the decision
                request_count,
            );

            println!("üîç Async HTTPS request {} completed (version: {}, keep_alive: {})",
                request_count, http_version, should_keep_alive);

            if !should_keep_alive {
                println!("DEBUG: Closing async HTTPS connection after {} requests (version: {})",
                    request_count, http_version);
                // Properly shut down the TLS connection
                use tokio::io::AsyncWriteExt;
                let _ = tls_stream.shutdown().await;
                break; // Exit the Keep-Alive loop
            }

            println!("DEBUG: Keeping async HTTPS connection alive for next request (version: {})",
                http_version);
        }

        Ok(())
    }

    /// Process a single HTTPS request using async tokio-rustls
    async fn process_https_request_async(
        tls_stream: &mut tokio_rustls::server::TlsStream<tokio::net::TcpStream>,
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: &SecureFileServer,
    ) -> Result<(HttpVersion, Option<String>), Box<dyn std::error::Error + Send + Sync>> {
        use tokio::io::{AsyncReadExt, AsyncWriteExt};

        // Read the request
        let mut buffer = [0; 4096];
        let n = tls_stream.read(&mut buffer).await?;
        if n == 0 {
            return Err("Connection closed by client".into());
        }

        let request = String::from_utf8_lossy(&buffer[..n]);
        println!("üîç Async HTTPS request received: {}", request.lines().next().unwrap_or(""));

        // Parse the request
        let lines: Vec<&str> = request.lines().collect();
        if lines.is_empty() {
            return Err("Empty request".into());
        }

        let first_line = lines[0];
        let parts: Vec<&str> = first_line.split_whitespace().collect();
        if parts.len() < 3 {
            return Err("Invalid request line".into());
        }

        let method = parts[0];
        let path = parts[1];
        let http_version_str = parts[2];

        // Parse HTTP version
        let http_version = HttpVersion::from_request_line(first_line);

        // Extract server name from Host header
        let server_name = lines.iter()
            .find(|line| line.starts_with("Host:"))
            .and_then(|line| line.split(':').nth(1))
            .map(|host| host.trim().to_string())
            .unwrap_or_else(|| "localhost".to_string());

        println!("üîç Async HTTPS request: {} {} {} (server: {})", method, path, http_version_str, server_name);

        // Extract connection header from request
        let connection_header = lines.iter()
            .find(|line| line.to_lowercase().starts_with("connection:"))
            .and_then(|line| line.split(':').nth(1))
            .map(|conn| conn.trim().to_string());

        // Handle ACME challenges
        if path.starts_with("/.well-known/acme-challenge/") {
            let token = path.trim_start_matches("/.well-known/acme-challenge/");
            let key_authorization = {
                let challenges = http_challenges.lock().unwrap();
                challenges.get(token).cloned()
            };
            if let Some(key_authorization) = key_authorization {
                let response = format!("HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
                    key_authorization.len(), key_authorization);
                tls_stream.write_all(response.as_bytes()).await?;
                tls_stream.flush().await?;
                return Ok((HttpVersion::Http11, Some("close".to_string())));
            }
        }

        // Check for admin extension requests
        #[cfg(feature = "extensions")]
        {
            println!("DEBUG: Async HTTPS - Checking for admin request with path: {}", path);
            let is_admin_request = {
                let registry = extension_registry.lock().unwrap();
                registry.is_admin_path(path)
            };
            println!("DEBUG: Async HTTPS - Admin request check result: {}", is_admin_request);
            if is_admin_request {
                println!("DEBUG: Async HTTPS - Admin request detected for path: {}", path);

                // Extract HTTP method
                let http_method = method;

                // Extract query string
                let query_string = if let Some(query_start) = path.find('?') {
                    &path[query_start + 1..]
                } else {
                    ""
                };

                // Extract the path without query string
                let admin_path = if let Some(query_start) = path.find('?') {
                    &path[..query_start]
                } else {
                    path
                };

                // Parse headers
                let mut headers = std::collections::HashMap::new();
                for line in lines.iter().skip(1) {
                    if let Some(colon_pos) = line.find(':') {
                        let key = line[..colon_pos].trim().to_lowercase();
                        let value = line[colon_pos + 1..].trim().to_string();
                        headers.insert(key, value);
                    }
                }

                // Read request body if present
                let body = if let Some(content_length_line) = lines.iter().find(|line| line.to_lowercase().starts_with("content-length:")) {
                    if let Some(length_str) = content_length_line.split(':').nth(1) {
                        if let Ok(length) = length_str.trim().parse::<usize>() {
                            let mut body_buffer = vec![0u8; length];
                            tls_stream.read_exact(&mut body_buffer).await?;
                            String::from_utf8_lossy(&body_buffer).to_string()
                        } else {
                            String::new()
                        }
                    } else {
                        String::new()
                    }
                } else {
                    String::new()
                };

                // Handle admin extension request
                let admin_response = extension_registry.lock().unwrap().process_admin_request(admin_path, http_method, query_string, &body, &headers);
                match admin_response {
                    Ok(response) => {
                        tls_stream.write_all(response.as_bytes()).await?;
                        tls_stream.flush().await?;
                        return Ok((http_version.clone(), Some("close".to_string())));
                    }
                    Err(e) => {
                        let error_response = format!("HTTP/1.1 500 Internal Server Error\r\nContent-Length: {}\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\nError: {}",
                            e.to_string().len() + 7, e);
                        tls_stream.write_all(error_response.as_bytes()).await?;
                        tls_stream.flush().await?;
                        return Ok((http_version.clone(), Some("close".to_string())));
                    }
                }
            }
        }

        // Determine if we should keep the connection alive (passed to response builder)
        // For now, we'll use a simple heuristic based on HTTP version
        let should_keep_alive_response = match &http_version {
            HttpVersion::Http10 | HttpVersion::Http09 => false,
            HttpVersion::Http11 => {
                // Check if client sent Connection: close
                connection_header.as_ref().map(|h| h.to_lowercase() != "close").unwrap_or(true)
            }
        };

        // Handle file serving with caching
        let file_result = secure_file_server.serve_file_with_domain_and_caching(
            path,
            Some(&server_name),
            &request,
            &http_version,
            should_keep_alive_response
        );

        // Convert error to string to make it Send
        let file_result = file_result.map_err(|e| format!("Error serving file: {}", e));

        match file_result {
            Ok(Some(response_bytes)) => {
                // This is a complete HTTP response (with caching headers)
                // Check if this is HTML content that needs extension processing
                let final_response_bytes = if let Ok(response_string) = String::from_utf8(response_bytes.clone()) {
                    if response_string.contains("text/html") {
                        // Check if the HTML body contains #EXTEND: directives
                        if let Some(body_start) = response_string.find("\r\n\r\n") {
                            let body = &response_string[body_start + 4..];
                            println!("DEBUG: Body length: {}", body.len());
                            println!("DEBUG: Body contains '#EXTEND:': {}", body.contains("#EXTEND:"));
                            if body.contains("#EXTEND:") {
                                println!("DEBUG: Found #EXTEND: directive in HTML body, processing extensions...");
                                // Process extensions in the HTML content
                                #[cfg(feature = "extensions")]
                                {
                                    println!("DEBUG: Extensions feature enabled, calling process_html...");
                                    let processed_html = extension_registry.lock().unwrap().process_html(body, path);
                                    println!("DEBUG: Extension processing completed, processed HTML length: {}", processed_html.len());
                                    // Reconstruct the response with processed HTML
                                    let headers = &response_string[..body_start];
                                    let new_content_length = processed_html.len();
                                    // Update Content-Length header
                                    let updated_headers = headers
                                        .lines()
                                        .map(|line| {
                                            if line.starts_with("Content-Length:") {
                                                format!("Content-Length: {}", new_content_length)
                                            } else {
                                                line.to_string()
                                            }
                                        })
                                        .collect::<Vec<String>>()
                                        .join("\r\n");
                                    format!("{}\r\n\r\n{}", updated_headers, processed_html).into_bytes()
                                }
                                #[cfg(not(feature = "extensions"))]
                                {
                                    response_bytes
                                }
                            } else {
                                response_bytes
                            }
                        } else {
                            response_bytes
                        }
                    } else {
                        response_bytes
                    }
                } else {
                    response_bytes
                };

                println!("üîç Serving {} bytes over async HTTPS", final_response_bytes.len());

                // Write in chunks to handle large files properly with tokio-rustls
                let chunk_size = 8192; // 8KB chunks
                let mut offset = 0;
                let mut retry_count = 0;
                const MAX_RETRIES: u32 = 3;

                while offset < final_response_bytes.len() {
                    let end = std::cmp::min(offset + chunk_size, final_response_bytes.len());
                    let chunk = &final_response_bytes[offset..end];

                    // Log progress for large files
                    if final_response_bytes.len() > 100000 && offset % (chunk_size * 10) == 0 {
                        println!("üîç HTTPS progress: {}/{} bytes ({}%)",
                            offset, final_response_bytes.len(),
                            (offset * 100) / final_response_bytes.len());
                    }

                    // Try to write the chunk with retry logic
                    let mut write_success = false;
                    for attempt in 0..MAX_RETRIES {
                        match tls_stream.write_all(chunk).await {
                            Ok(_) => {
                                // Successfully wrote the chunk
                                offset = end;
                                write_success = true;
                                retry_count = 0; // Reset retry count on success
                                break;
                            }
                            Err(e) => {
                                retry_count += 1;
                                eprintln!("Error writing chunk at offset {} (attempt {}): {}", offset, attempt + 1, e);

                                if attempt < MAX_RETRIES - 1 {
                                    // Wait a bit before retrying
                                    std::thread::sleep(std::time::Duration::from_millis(10));
                                } else {
                                    return Err(e.into());
                                }
                            }
                        }
                    }

                    if !write_success {
                        return Err("Failed to write chunk after maximum retries".into());
                    }

                    // Flush after each chunk to ensure data is sent
                    if let Err(e) = tls_stream.flush().await {
                        eprintln!("Error flushing after chunk at offset {}: {}", offset, e);
                        return Err(e.into());
                    }
                }

                println!("üîç Successfully served {} bytes over async HTTPS", final_response_bytes.len());
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page(&server_name);
                    let response = format!("HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: {}\r\n\r\n{}",
                        default_page.len(), default_page);
                    tls_stream.write_all(response.as_bytes()).await?;
                    tls_stream.flush().await?;
                } else {
                    // 404 Not Found
                    let response = "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: 13\r\n\r\n404 Not Found";
                    tls_stream.write_all(response.as_bytes()).await?;
                    tls_stream.flush().await?;
                }
            }
            Err(error_msg) => {
                eprintln!("{}", error_msg);
                let response = "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\nContent-Length: 21\r\n\r\n500 Internal Server Error";
                let response_bytes = response.as_bytes().to_vec();
                tls_stream.write_all(&response_bytes).await?;
                tls_stream.flush().await?;
            }
        }

        // Return HTTP version and connection header
        Ok((http_version, connection_header))
    }

    /// Handle HTTPS connection in blocking context (for rustls compatibility)
    fn handle_https_connection_blocking(
        mut stream: std::net::TcpStream,
        cert_resolver: Arc<dyn ResolvesServerCert + Send + Sync>,
        args: Args,
        extension_registry: Arc<Mutex<ExtensionRegistry>>,
        http_challenges: Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: SecureFileServer,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç Starting blocking HTTPS connection handling");

        // Create server config with our certificate resolver
        // Use ring provider for better Safari 6-8 compatibility
        let server_config = ServerConfig::builder_with_provider(
            rustls::crypto::ring::default_provider().into()
        )
        .with_no_client_auth()
        .with_cert_resolver(cert_resolver)
        .map_err(|e| {
            println!("‚ùå Failed to create server config: {}", e);
            format!("Failed to create server config: {}", e)
        })?;

        println!("‚úÖ Server config created successfully");

        // Create a new acceptor for this connection
        let mut acceptor = Acceptor::default();

        // Read TLS packets until we have a complete ClientHello
        let accepted = loop {
            match acceptor.read_tls(&mut stream) {
                Ok(0) => {
                    println!("üîç Connection closed by client");
                    return Ok(()); // Connection closed
                }
                        Ok(_) => {
                            match acceptor.accept() {
                    Ok(Some(accepted)) => {
                        break accepted;
                    }
                    Ok(None) => {
                        continue;
                    }
                        Err((e, mut alert)) => {
                            println!("‚ùå Error accepting connection: {}", e);
                            let _ = alert.write_all(&mut stream);
                            return Err(format!("Error accepting connection: {}", e).into());
                        }
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, continue
                    continue;
                }
                Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => {
                    println!("üîç Client disconnected unexpectedly");
                    return Ok(());
                }
                Err(e) => {
                    println!("‚ùå Error reading TLS: {}", e);
                    return Err(e.into());
                }
            }
        };

        // Get the server name from ClientHello
        let server_name = accepted.client_hello().server_name()
            .map(|name| name.as_ref().to_string())
            .unwrap_or_else(|| "unknown".to_string());

        // Complete the TLS handshake
        let mut conn = match accepted.into_connection(Arc::new(server_config)) {
            Ok(conn) => {
                println!("‚úÖ TLS handshake completed successfully for domain: {}", server_name);
                conn
            }
            Err((e, mut alert)) => {
                println!("‚ùå Error completing TLS handshake: {}", e);
                println!("üîç Error details: {:?}", e);
                let _ = alert.write_all(&mut stream);
                return Err(format!("Error completing connection: {}", e).into());
            }
        };

        // Handle the connection with Keep-Alive support
        println!("üîç Starting HTTPS Keep-Alive loop for domain: {}", server_name);

        let connection_policy = ConnectionPolicy::default();
        let mut request_count = 0;

        loop {
            request_count += 1;

            println!("üîç Processing HTTPS request {} for domain: {}", request_count, server_name);

            // Process the request and get parsed version/connection info
            let (http_version, connection_header) = Self::process_https_request_static_blocking(&mut stream, &mut conn, &server_name, &extension_registry, &http_challenges, &secure_file_server)?;

            // Determine if we should keep the connection alive
            let should_keep_alive = connection_policy.should_keep_alive(
                &http_version,
                connection_header.as_deref(),
                0, // We don't have response size here, but it's not critical for the decision
                request_count,
            );

            println!("üîç HTTPS request {} completed (version: {}, keep_alive: {})",
                request_count, http_version, should_keep_alive);

            if !should_keep_alive {
                println!("DEBUG: Closing HTTPS connection after {} requests (version: {})",
                    request_count, http_version);
                break; // Exit the Keep-Alive loop
            }

            println!("DEBUG: Keeping HTTPS connection alive for next request (version: {})",
                http_version);
        }

        Ok(())
    }


    /// Handle a single HTTPS connection

    /// Handle admin request for HTTPS (centralized)
    #[cfg(feature = "extensions")]
    fn handle_admin_request_https(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_path: &str,
        lines: &[&str],
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        println!("DEBUG: Admin request detected for path: {}", request_path);

        // Extract HTTP method from the first line
        let http_method = if let Some(first_line) = lines.first() {
            first_line.split_whitespace().next().unwrap_or("GET")
        } else {
            "GET"
        };
        println!("DEBUG: HTTP method: {}", http_method);

        // Extract query string from the request
        let query_string = if let Some(query_start) = request_path.find('?') {
            &request_path[query_start + 1..]
        } else {
            ""
        };

        // Extract the path without query string
        let admin_path = if let Some(query_start) = request_path.find('?') {
            &request_path[..query_start]
        } else {
            request_path
        };

        // Parse headers
        let mut headers = std::collections::HashMap::new();
        let mut body = String::new();
        let mut in_body = false;

        for line in &lines[1..] {
            if in_body {
                body.push_str(line);
                body.push('\n');
            } else if line.is_empty() {
                in_body = true; // Empty line indicates start of body
            } else if let Some(colon_pos) = line.find(':') {
                let header_name = line[..colon_pos].trim().to_lowercase();
                let header_value = line[colon_pos + 1..].trim().to_string();
                headers.insert(header_name, header_value);
            }
        }

        // Remove trailing newline from body
        if body.ends_with('\n') {
            body.pop();
        }

        // Handle admin extension request using the centralized system
        let admin_response = extension_registry.lock().unwrap().process_admin_request(admin_path, http_method, query_string, &body, &headers);
        match admin_response {
            Ok(response) => {
                conn.writer().write_all(response.as_bytes())?;
                conn.write_tls(stream)?;
                conn.complete_io(stream)?;
                Ok(())
            }
            Err(e) => {
                let error_msg = format!("Error: {}", e);

                // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
                let mut response = HttpResponse::internal_server_error(error_msg.as_bytes().to_vec());
                response.set_content_type("text/plain");
                response.set_content_length();

                let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
                conn.writer().write_all(&response_bytes)?;
                conn.write_tls(stream)?;
                conn.complete_io(stream)?;
                Ok(())
            }
        }
    }

    /// Process HTTPS request and send response (blocking version for rustls)
    fn process_https_request_static_blocking(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        secure_file_server: &SecureFileServer,
    ) -> Result<(HttpVersion, Option<String>), Box<dyn std::error::Error + Send + Sync>> {
        println!("üîç process_https_request_static started for domain: {}", server_name);
        // TLS handshake is already completed in the main connection handler
        println!("üîç TLS handshake already completed for domain: {}", server_name);

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        println!("üîç Starting to read HTTP request for domain: {}", server_name);

        // TLS I/O is already completed in the main connection handler
        println!("üîç TLS I/O already completed for domain: {}", server_name);

        // Read data in a loop to handle partial reads
        let mut read_attempts = 0;
        const MAX_READ_ATTEMPTS: usize = 1000; // 10 seconds with 10ms sleep

        loop {
            read_attempts += 1;
            if read_attempts > MAX_READ_ATTEMPTS {
                println!("üîç Timeout waiting for HTTP request from domain: {}", server_name);
                return Err("Timeout waiting for HTTP request".into());
            }

            //println!("üîç Attempting to read data for domain: {} (total_read: {}, attempt: {})", server_name, total_read, read_attempts);

            // First, try to complete any pending TLS I/O
            match conn.complete_io(stream) {
                Ok((0, 0)) => {
                    println!("üîç Connection closed for domain: {}", server_name);
                    break; // Connection closed
                }
                Ok(_) => {
                    // TLS I/O completed, now try to read data
                    match conn.reader().read(&mut buffer[total_read..]) {
                        Ok(0) => {
                            println!("üîç Connection closed for domain: {}", server_name);
                            break; // Connection closed
                        }
                        Ok(n) => {
                            println!("üîç Read {} bytes for domain: {}", n, server_name);
                            total_read += n;
                            if total_read >= buffer.len() {
                                println!("üîç Buffer full for domain: {}", server_name);
                                break; // Buffer full
                            }
                            // Check if we have a complete HTTP request
                            if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                                println!("üîç Current request data for domain {}: {}", server_name, request_str);
                                if request_str.contains("\r\n\r\n") {
                                    println!("üîç Complete HTTP request received for domain: {}", server_name);
                                    break; // Complete HTTP request received
                                }
                            }
                        }
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                            println!("üîç WouldBlock error for domain: {}, waiting... (attempt {})", server_name, read_attempts);
                            // No data available, wait a bit
                            std::thread::sleep(std::time::Duration::from_millis(10));
                            continue;
                        }
                        Err(e) => {
                            println!("üîç Read error for domain {}: {}", server_name, e);
                            return Err(e.into());
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    //println!("üîç TLS I/O WouldBlock for domain: {}, waiting... (attempt {})", server_name, read_attempts);
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => {
                    println!("üîç TLS I/O error for domain {}: {}", server_name, e);
                    return Err(e.into());
                }
            }
        }

        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        // Parse HTTP version and connection header for Keep-Alive support
        let (http_version, connection_header) = ConnectionPolicy::parse_request_info(&request);

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       Self::handle_acme_challenge_static(stream, conn, first_line, &None, http_challenges)?;
                       // ACME challenges don't need Keep-Alive, always close
                       return Ok((HttpVersion::Http11, Some("close".to_string())));
                   }
        }


        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                let path_with_query = &first_line[path_start + 1..];
                // Find the end of the path (either next space or query string)
                let path_end = if let Some(query_start) = path_with_query.find('?') {
                    query_start
                } else if let Some(space_pos) = path_with_query.find(' ') {
                    space_pos
                } else {
                    path_with_query.len()
                };
                &path_with_query[..path_end]
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        // Check for admin extension requests
        #[cfg(feature = "extensions")]
        {
            println!("DEBUG: HTTPS - Checking for admin request with path: {}", request_path);
            let is_admin_request = {
                let registry = extension_registry.lock().unwrap();
                registry.is_admin_path(request_path)
            };
            println!("DEBUG: HTTPS - Admin request check result: {}", is_admin_request);
            if is_admin_request {
                println!("DEBUG: HTTPS - Admin request detected for path: {}", request_path);
                Self::handle_admin_request_https(stream, conn, request_path, &lines, extension_registry)?;
                return Ok((http_version.clone(), connection_header.clone()));
            }
        }

        // Check for bin extension requests (CGI-like)
        if request_path.starts_with("/cgi-bin/") {
            // Extract query string from the original request line
            let query_string = if let Some(first_line) = lines.first() {
                if let Some(path_start) = first_line.find(' ') {
                    let path_with_query = &first_line[path_start + 1..];
                    if let Some(query_start) = path_with_query.find('?') {
                        let query_part = &path_with_query[query_start + 1..];
                        if let Some(space_pos) = query_part.find(' ') {
                            &query_part[..space_pos]
                        } else {
                            query_part
                        }
                    } else {
                        ""
                    }
                } else {
                    ""
                }
            } else {
                ""
            };

            // Extract the path without query string (already done above)
            let bin_path = request_path;

            // Parse headers
            let mut headers = std::collections::HashMap::new();
            for line in &lines[1..] {
                if let Some(colon_pos) = line.find(':') {
                    let header_name = line[..colon_pos].trim().to_lowercase();
                    let header_value = line[colon_pos + 1..].trim().to_string();
                    headers.insert(header_name, header_value);
                }
            }

            // Handle bin extension request
            let response = {
                let registry = extension_registry.lock().unwrap();
                registry.handle_bin_request(bin_path, "GET", query_string, &headers)
            };

            match response {
                Ok(response_body) => {
                    conn.writer().write_all(response_body.as_bytes())?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                    return Ok((http_version.clone(), connection_header.clone()));
                }
                Err(e) => {
                    let error_msg = format!("Error: {}", e);

                    // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
                    let mut response = HttpResponse::internal_server_error(error_msg.as_bytes().to_vec());
                    response.set_content_type("text/plain");
                    response.set_content_length();

                    let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
                    conn.writer().write_all(&response_bytes)?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                    return Ok((http_version.clone(), connection_header.clone()));
                }
            }
        }

        // Try to serve the requested file using secure file server with caching support
        match secure_file_server.serve_file_with_domain_and_caching(
            request_path,
            Some(server_name),
            &request,
            &HttpVersion::Http11,
            false // Default to close for HTTPS
        ) {
            Ok(Some(response_bytes)) => {
                // This is a complete HTTP response (with caching headers)
                // Try to write the entire response at once
                conn.writer().write_all(&response_bytes)?;

                // Complete TLS I/O in a loop to handle large responses
                loop {
                    match conn.write_tls(stream) {
                        Ok(0) => break, // No more data to write
                        Ok(_) => {
                            // More data written, continue
                        }
                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                            // Would block, try again
                                    continue;
                                }
                                Err(e) => return Err(e.into()),
                            }
                        }

                // Complete any remaining I/O
                    conn.complete_io(stream)?;
            }
            Ok(None) => {
                // File not found - check if this is a root request (index.html missing)
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page
                    let default_page = secure_file_server.generate_default_page(server_name);

                    // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
                    conn.writer().write_all(&response_bytes)?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // File not found, send 404 for non-root requests
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
            Err(e) => {
                // Security error or other error - check if this is a root request first
                println!("Request denied for {}: {}", request_path, e);
                if secure_file_server.is_root_request(request_path) {
                    // Serve default informational page even for security errors on root
                    let default_page = secure_file_server.generate_default_page(server_name);

                    // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
                    let mut response = HttpResponse::ok(default_page.as_bytes().to_vec());
                    response.set_content_type("text/html; charset=utf-8");
                    response.set_content_length();
                    response.add_security_headers();

                    let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
                    conn.writer().write_all(&response_bytes)?;
                    conn.write_tls(stream)?;
                    conn.complete_io(stream)?;
                } else {
                    // Send 404 for non-root requests with security errors
                    Self::send_error_response_static(conn, stream, 404, "Not Found")?;
                }
            }
        }

        Ok((http_version, connection_header))
    }

    /// Process HTTPS request and send response
    fn process_https_request(
        &self,
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        server_name: &str,
        extension_registry: &Arc<Mutex<ExtensionRegistry>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Complete the handshake
        conn.complete_io(stream)?;

        // Read HTTP request using the TLS connection
        let mut buffer = [0; 4096];
        let mut total_read = 0;

        // Read data in a loop to handle partial reads
        loop {
            match conn.reader().read(&mut buffer[total_read..]) {
                Ok(0) => break, // Connection closed
                Ok(n) => {
                    total_read += n;
                    if total_read >= buffer.len() {
                        break; // Buffer full
                    }
                    // Check if we have a complete HTTP request
                    if let Ok(request_str) = std::str::from_utf8(&buffer[..total_read]) {
                        if request_str.contains("\r\n\r\n") {
                            break; // Complete HTTP request received
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    // No data available, wait a bit
                    std::thread::sleep(std::time::Duration::from_millis(10));
                    continue;
                }
                Err(e) => return Err(e.into()),
            }
        }

        let n = total_read;

        // Parse HTTP request (simplified)
        let request = String::from_utf8_lossy(&buffer[..n]);
        let lines: Vec<&str> = request.lines().collect();

        if let Some(first_line) = lines.first() {
            println!("HTTP Request: {}", first_line);

                   // Handle HTTP-01 ACME challenges
                   if first_line.starts_with("GET /.well-known/acme-challenge/") {
                       return Self::handle_acme_challenge(stream, conn, first_line, &self.acme_client, http_challenges);
                   }
        }

        // Extract the request path from the HTTP request
        let request_path = if let Some(first_line) = lines.first() {
            if let Some(path_start) = first_line.find(' ') {
                if let Some(path_end) = first_line[path_start + 1..].find(' ') {
                    &first_line[path_start + 1..path_start + 1 + path_end]
                } else {
                    "/"
                }
            } else {
                "/"
            }
        } else {
            "/"
        };

        println!("Requested path: {}", request_path);

        // Try to serve the requested file using secure file server with caching support
        match self.secure_file_server.serve_file_with_domain_and_caching(
            request_path,
            Some(server_name),
            &request,
            &HttpVersion::Http11,
            false // Default to close for HTTPS
        ) {
            Ok(Some(response_bytes)) => {
                // This is a complete HTTP response (with caching headers)
                conn.writer().write_all(&response_bytes)?;
                        conn.write_tls(stream)?;
                        conn.complete_io(stream)?;
                return Ok(());
            }
            Ok(None) => {
                // File not found, send 404
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
            Err(e) => {
                // Security error or other error, send 403 or 404 for security
                println!("Request denied for {}: {}", request_path, e);
                Self::send_error_response(conn, stream, 404, "Not Found")?;
            }
        }

        Ok(())
    }

    /// Send an error response (static version for threading)
    fn send_error_response_static(
        conn: &mut ServerConnection,
        stream: &mut std::net::TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>easyp HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
        let mut response = HttpResponse::new(status_code, status_text, body.as_bytes().to_vec());
        response.set_content_type("text/html; charset=utf-8");
        response.set_content_length();

        let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
        conn.writer().write_all(&response_bytes)?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Send an error response
    fn send_error_response(
        conn: &mut ServerConnection,
        stream: &mut std::net::TcpStream,
        status_code: u16,
        status_text: &str,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let body = format!(
            "<!DOCTYPE html>\n\
             <html>\n\
             <head>\n\
                 <title>{} {}</title>\n\
                 <style>\n\
                     body {{ font-family: Arial, sans-serif; margin: 40px; text-align: center; }}\n\
                     .error {{ background: #e74c3c; color: white; padding: 20px; border-radius: 5px; display: inline-block; }}\n\
                 </style>\n\
             </head>\n\
             <body>\n\
                 <div class=\"error\">\n\
                     <h1>{} {}</h1>\n\
                     <p>easyp HTTPS Server</p>\n\
                 </div>\n\
             </body>\n\
             </html>",
            status_code, status_text, status_code, status_text
        );

        // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
        let mut response = HttpResponse::new(status_code, status_text, body.as_bytes().to_vec());
        response.set_content_type("text/html; charset=utf-8");
        response.set_content_length();

        let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
        conn.writer().write_all(&response_bytes)?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTP (port 80)
    async fn handle_acme_challenge_http(
        mut stream: tokio::net::TcpStream,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTP)
            let mut response = HttpResponse::ok(key_auth.as_bytes().to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();
            response.set_cache_control("no-cache");

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTP
            response_bytes
        } else {
            println!("Challenge token not found: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTP)
            let mut response = HttpResponse::not_found(b"Not Found".to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTP
            response_bytes
        };

        stream.write_all(&response).await?;
        stream.flush().await?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443) - static version for threading
    fn handle_acme_challenge_static(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params_static(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
            let mut response = HttpResponse::ok(key_auth.as_bytes().to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();
            response.set_cache_control("no-cache");

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
            response_bytes
        } else {
            println!("Challenge token not found: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
            let mut response = HttpResponse::not_found(b"Not Found".to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
            response_bytes
        };

        conn.writer().write_all(&response)?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Handle HTTP-01 ACME challenge over HTTPS (port 443)
    fn handle_acme_challenge(
        stream: &mut std::net::TcpStream,
        conn: &mut ServerConnection,
        request_line: &str,
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Extract token from request path
        // GET /.well-known/acme-challenge/{token} HTTP/1.1
        let path = request_line.split_whitespace().nth(1).unwrap_or("");
        let token = path.strip_prefix("/.well-known/acme-challenge/").unwrap_or("");

        println!("ACME HTTP-01 challenge request for token: {}", token);

        // Look up the key authorization for this token
        let key_authorization = Self::get_challenge_response_from_params(acme_client, http_challenges, token);

        let response = if let Some(key_auth) = key_authorization {
            println!("Serving challenge response for token: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
            let mut response = HttpResponse::ok(key_auth.as_bytes().to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();
            response.set_cache_control("no-cache");

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
            response_bytes
        } else {
            println!("Challenge token not found: {}", token);

            // Use HttpResponse builder for version-aware response (default to HTTP/1.1 for HTTPS)
            let mut response = HttpResponse::not_found(b"Not Found".to_vec());
            response.set_content_type("text/plain");
            response.set_content_length();

            let response_bytes = response.encode(&HttpVersion::Http11, false); // Default to close for HTTPS
            response_bytes
        };

        conn.writer().write_all(&response)?;
        conn.write_tls(stream)?;
        conn.complete_io(stream)?;

        Ok(())
    }

    /// Get challenge response for a token from ACME client
    fn get_challenge_response(&self, token: &str) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = &self.acme_client {
            let rt = tokio::runtime::Runtime::new().unwrap();
            if let Some(response) = rt.block_on(acme_client.get_challenge_response(token)) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = self.http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params_static(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            // Use block_in_place to handle the async call within the existing runtime
            if let Some(response) = tokio::task::block_in_place(|| {
                tokio::runtime::Handle::try_current()
                    .unwrap()
                    .block_on(acme_client.get_challenge_response(token))
            }) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    /// Get challenge response for a token from parameters (static method)
    fn get_challenge_response_from_params(
        acme_client: &Option<Arc<AcmeClient>>,
        http_challenges: &Arc<Mutex<BTreeMap<String, String>>>,
        token: &str,
    ) -> Option<String> {
        // Try to get from ACME client if available
        if let Some(acme_client) = acme_client {
            // Use block_in_place to handle the async call within the existing runtime
            if let Some(response) = tokio::task::block_in_place(|| {
                tokio::runtime::Handle::try_current()
                    .unwrap()
                    .block_on(acme_client.get_challenge_response(token))
            }) {
                return Some(response);
            }
        }

        // Fallback to local storage
        if let Ok(challenges) = http_challenges.lock() {
            if let Some(response) = challenges.get(token) {
                return Some(response.clone());
            }
        }

        // Last resort: placeholder response
        if !token.is_empty() {
            Some(format!("challenge-response-for-{}", token))
        } else {
            None
        }
    }

    // No more challenge syncing needed - challenges are accessed directly from ACME client
}


/// Ensure /tmp/acme_certs directory exists and is owned by www-data (acme-lib requirement)
fn ensure_tmp_acme_permissions(uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    let tmp_acme_dir = "/tmp/acme_certs";

    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to create /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set ownership to www-data
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755
    let output = Command::new("chmod")
        .args(&["-R", "755", tmp_acme_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of /tmp/acme_certs directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("Certificate cache directory permissions set: {} (owner: {})", tmp_acme_dir, uid);
    Ok(())
}

// DomainRequestLogger removed - was unused dead code


/// Ensure certificate cache directory has proper ownership for www-data
fn ensure_cert_cache_permissions(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    // Create the directory if it doesn't exist
    let output = Command::new("mkdir")
        .args(&["-p", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to create certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Create subdirectories that ACME client needs (based on environment)
    let staging_dir = format!("{}/staging", cache_dir);
    let production_dir = format!("{}/production", cache_dir);

    for dir in [&staging_dir, &production_dir] {
        let output = Command::new("mkdir")
            .args(&["-p", dir])
            .output()?;

        if !output.status.success() {
            return Err(format!("Failed to create certificate directory {}: {}", dir, String::from_utf8_lossy(&output.stderr)).into());
        }
    }

    // Set ownership to www-data recursively
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755 recursively
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of certificate cache directory: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("Certificate cache directory permissions set: {} (owner: {})", cache_dir, uid);
    Ok(())
}

/// Ensure ACME cache directory is properly set up with www-data permissions
fn ensure_acme_cache_directory(cache_dir: &str, uid: u32, gid: u32) -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    // Create the main cache directory
    std::fs::create_dir_all(cache_dir)?;

    // Create the acme_lib subdirectory
    let acme_lib_dir = format!("{}/acme_lib", cache_dir);
    //TODO
    std::fs::create_dir_all(&acme_lib_dir)?;

    // Set ownership to www-data for both directories
    let output = Command::new("chown")
        .args(&["-R", &format!("{}:{}", uid, gid), cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set ownership of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }

    // Set permissions to 755 for both directories
    let output = Command::new("chmod")
        .args(&["-R", "755", cache_dir])
        .output()?;

    if !output.status.success() {
        return Err(format!("Failed to set permissions of ACME cache directory '{}': {}", cache_dir, String::from_utf8_lossy(&output.stderr)).into());
    }

    println!("ACME cache directory permissions set: {} (owner: {})", cache_dir, uid);
    println!("ACME lib directory created: {}", acme_lib_dir);
    Ok(())
}

/// Check if www-data user exists by parsing /etc/passwd (Redox-specific)
#[cfg(target_os = "redox")]
fn check_www_data_user_exists() -> Result<bool, Box<dyn std::error::Error>> {
    use std::fs;
    use std::io::{BufRead, BufReader};

    let passwd_content = fs::read_to_string("/etc/passwd")?;
    let reader = BufReader::new(passwd_content.as_bytes());

    for line in reader.lines() {
        let line = line?;
        //Redox uses ; instead of :?
        let parts: Vec<&str> = line.split(';').collect();

        if parts.len() >= 1 && parts[0] == "www-data" {
            return Ok(true);
        }
    }

    Ok(false)
}

/// Ensure www-data user exists, create if necessary (only when running as root)
#[cfg(unix)]
fn ensure_www_data_user() -> Result<(), Box<dyn std::error::Error>> {
    use std::process::Command;

    // Only attempt to create user if running as root
    if !is_running_as_root() {
        return Err("Cannot create www-data user: not running as root".into());
    }

    #[cfg(target_os = "redox")]
    {
        // For Redox, check /etc/passwd instead of using id command
        if check_www_data_user_exists()? {
            // User exists, nothing to do
            return Ok(());
        }
    }

    #[cfg(not(target_os = "redox"))]
    {
        // For other Unix systems, use the id command as before
        // Check if www-data user exists
        let check_output = Command::new("id")
            .args(&["-u", "www-data"])
            .output()?;

        if check_output.status.success() {
            // User exists, nothing to do
            return Ok(());
        }
    }

    println!("www-data user not found, creating...");

    // Create www-data group first
    #[cfg(not(target_os = "redox"))]
    let group_output = Command::new("groupadd")
        .args(&["www-data"])
        .output()?;
    //docker run -v D:\src\easyp:/easyp -v D:\src\ring-redox:/ring-redox -it docker.io/redoxos/redoxer:latest
    #[cfg(not(target_os = "redox"))]
    if !group_output.status.success() {
        let stderr = String::from_utf8_lossy(&group_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data group: {}", stderr).into());
        }
    }

    // Create www-data user
    #[cfg(not(target_os = "redox"))]
    let user_output = Command::new("useradd")
        .args(&["-r", "-g", "www-data", "-s", "/bin/false", "-d", "/var/www", "www-data"])
        .output()?;

    #[cfg(target_os = "redox")]
    let user_output = Command::new("useradd")
        .args(&["-s", "/bin/false", "www-data"])
        .output()?;
    #[cfg(target_os = "redox")]
    {

    // then sleep for a second
    //std::thread::sleep(std::time::Duration::from_secs(10));
    println!("user_output: {:?}", user_output);
    println!("user_output.status: {:?}", user_output.status);
    println!("user_output.stdout: {:?}", user_output.stdout);
    println!("user_output.stderr: {:?}", user_output.stderr);

    // Print the contents of /etc/passwd for diagnostic purposes

        use std::fs;
        match fs::read_to_string("/etc/passwd") {
            Ok(contents) => {
                println!("Contents of /etc/passwd:\n{}", contents);
            }
            Err(e) => {
                println!("Failed to read /etc/passwd: {}", e);
            }
        }
    }




    if !user_output.status.success() {
        let stderr = String::from_utf8_lossy(&user_output.stderr);
        if !stderr.contains("already exists") {
            return Err(format!("Failed to create www-data user: {}", stderr).into());
        }
    }

    println!("‚úÖ www-data user created successfully");
    Ok(())
}

/// Parse /etc/passwd to get www-data UID and GID (Redox-specific)
#[cfg(target_os = "redox")]
fn parse_www_data_from_passwd() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    use std::fs;
    use std::io::{BufRead, BufReader};

    let passwd_content = fs::read_to_string("/etc/passwd")?;
    let reader = BufReader::new(passwd_content.as_bytes());

    for line in reader.lines() {
        let line = line?;
        let parts: Vec<&str> = line.split(';').collect();

        // /etc/passwd format: username:password:uid:gid:gecos:home:shell
        if parts.len() >= 4 && parts[0] == "www-data" {
            let uid = parts[1].parse::<u32>()?;
            let gid = parts[2].parse::<u32>()?;
            return Ok((uid, gid));
        }
    }

    Err("www-data user not found in /etc/passwd".into())
}

/// Check if the current process is running as root
#[cfg(unix)]
fn is_running_as_root() -> bool {
    unsafe { libc::geteuid() == 0 }
}

#[cfg(not(unix))]
fn is_running_as_root() -> bool {
    false // On non-Unix systems, assume not root
}

/// Look up the UID and GID for the www-data user
#[cfg(unix)]
fn get_www_data_uid_gid() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    // Ensure www-data user exists first
    ensure_www_data_user()?;

    #[cfg(target_os = "redox")]
    {
        // For Redox, parse /etc/passwd instead of using id command
        parse_www_data_from_passwd()
    }

    #[cfg(not(target_os = "redox"))]
    {
        // For other Unix systems, use the id command as before
        use std::process::Command;

        // Try to get UID for www-data
        let uid_output = Command::new("id")
            .args(&["-u", "www-data"])
            .output()?;

        if !uid_output.status.success() {
            return Err("www-data user not found after creation attempt".into());
        }

        let uid_str = String::from_utf8(uid_output.stdout)?;
        let uid = uid_str.trim().parse::<u32>()?;

        // Try to get GID for www-data
        let gid_output = Command::new("id")
            .args(&["-g", "www-data"])
            .output()?;

        if !gid_output.status.success() {
            return Err("www-data group not found".into());
        }

        let gid_str = String::from_utf8(gid_output.stdout)?;
        let gid = gid_str.trim().parse::<u32>()?;

        Ok((uid, gid))
    }
}

/// Fallback for non-UNIX systems - returns dummy values
#[cfg(not(unix))]
fn get_www_data_uid_gid() -> Result<(u32, u32), Box<dyn std::error::Error>> {
    println!("Warning: Running without unix feature - using dummy UID/GID values");
    Ok((1000, 1000)) // Dummy values for non-UNIX systems
}

/// Automatically detect the server's IP addresses from network interfaces
#[cfg(not(target_os = "redox"))]
fn detect_server_ips() -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    use get_if_addrs::{get_if_addrs, IfAddr};

    let interfaces = get_if_addrs()?;
    let mut ip_addresses = Vec::new();

    for interface in interfaces {
        match interface.addr {
            IfAddr::V4(ipv4) => {
                let ip = ipv4.ip;
                // Filter out localhost and loopback addresses
                if !ip.is_loopback() && !ip.is_unspecified() {
                    ip_addresses.push(IpAddr::V4(ip));
                }
            }
            IfAddr::V6(ipv6) => {
                let ip = ipv6.ip;
                // Filter out localhost and loopback addresses
                if !ip.is_loopback() && !ip.is_unspecified() {
                    ip_addresses.push(IpAddr::V6(ip));
                }
            }
        }
    }

    println!("Detected {} IP addresses: {:?}", ip_addresses.len(), ip_addresses);
    Ok(ip_addresses)
}

/// Parse comma-separated IP addresses
fn parse_allowed_ips(ips_str: &str) -> Result<Vec<IpAddr>, Box<dyn std::error::Error>> {
    let mut ips = Vec::new();

    for ip_str in ips_str.split(',') {
        let ip_str = ip_str.trim();
        if ip_str.is_empty() {
            continue;
        }

        let ip: IpAddr = ip_str.parse()?;
        ips.push(ip);
    }

    Ok(ips)
}

/// Get admin keys from the admin_keys file
fn get_admin_keys() -> Result<std::collections::HashSet<String>, Box<dyn std::error::Error>> {
    let admin_keys_file = std::path::Path::new("/var/lib/easyp/admin_keys");
    let mut admin_keys = std::collections::HashSet::new();

    println!("DEBUG: Checking admin keys file: {:?}", admin_keys_file);
    println!("DEBUG: File exists: {}", admin_keys_file.exists());

    if admin_keys_file.exists() {
        if let Ok(content) = std::fs::read_to_string(admin_keys_file) {
            for line in content.lines() {
                if !line.is_empty() {
                    admin_keys.insert(line.to_string());
                }
            }
        }
    }

    Ok(admin_keys)
}

/// Get domains from certificate cache and add localhost
fn get_domains(cache_dir: &str) -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let mut domains = Vec::new();

    // Add localhost
    domains.push("localhost".to_string());

    // Scan certificate cache directory for domains (both staging and production)
    let cache_path = std::path::Path::new(cache_dir);
    if cache_path.exists() {
        // Check both staging and production subdirectories
        for subdir in ["staging", "production"] {
            let subdir_path = cache_path.join(subdir);
            if subdir_path.exists() {
                if let Ok(entries) = std::fs::read_dir(&subdir_path) {
                    for entry in entries {
                        if let Ok(entry) = entry {
                            if let Some(file_name) = entry.file_name().to_str() {
                                // Look for various certificate file patterns
                                if file_name.ends_with(".crt") || file_name.ends_with(".pem") {
                                    // Extract domain from filename patterns like:
                                    // - ca.dansted.org.crt
                                    // - 1234567890_crt_ca_dansted_org.crt
                                    // - 1234567890_crt_www_dansted_org.crt
                                    let domain = if file_name.contains("_crt_") {
                                        // Pattern: 1234567890_crt_domain_name.crt
                                        if let Some(start) = file_name.find("_crt_") {
                                            let domain_part = &file_name[start + 5..];
                                            let domain_part = domain_part.trim_end_matches(".crt");
                                            // Replace underscores with dots
                                            domain_part.replace("_", ".")
                                        } else {
                                            continue;
                                        }
                                    } else {
                                        // Pattern: domain.com.crt
                                        file_name.trim_end_matches(".crt").trim_end_matches(".pem").to_string()
                                    };

                                    // Filter out non-domain filenames (like "fullchain", "privkey", etc.)
                                    if !domain.is_empty()
                                        && !domains.contains(&domain)
                                        && domain.contains(".")
                                        && !domain.starts_with("cached_")
                                        && !domain.starts_with("fullchain")
                                        && !domain.starts_with("privkey")
                                        && !domain.starts_with("acme_") {
                                        domains.push(domain);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(domains)
}

/// Check if HTML body contains only constant extensions
/// Constant extensions are those that produce the same output for the same URL
fn check_constant_extensions_only(body: &str) -> bool {
    // List of known constant extensions
    // These extensions produce the same output for a given URL and can be cached
    let constant_extensions = [
        "comment",      // Comment system - same form for same URL
        "math",         // Math extension - deterministic calculations
        "example",      // Example extension - static content
    ];

    // List of known dynamic extensions
    // These extensions may produce different output and should not be cached
    let dynamic_extensions = [
        "time",         // Time-based content
        "random",       // Random content
        "counter",      // Counter that increments
    ];

    // Find all #EXTEND: directives in the body
    let mut start = 0;
    while let Some(extend_pos) = body[start..].find("#EXTEND:") {
        let full_pos = start + extend_pos;

        // Find the end of the directive
        if let Some(end_pos) = body[full_pos..].find(')') {
            let directive = &body[full_pos..full_pos + end_pos + 1];

            // Extract extension name
            if let Some(colon_pos) = directive.find(':') {
                let after_colon = &directive[colon_pos + 1..];
                if let Some(paren_pos) = after_colon.find('(') {
                    let ext_name = &after_colon[..paren_pos];

                    // Check if this is a dynamic extension
                    if dynamic_extensions.contains(&ext_name) {
                        println!("DEBUG: Found dynamic extension: {}", ext_name);
                        return false;
                    }

                    // If it's not in our constant list, assume it's dynamic for safety
                    if !constant_extensions.contains(&ext_name) {
                        println!("DEBUG: Unknown extension '{}', assuming dynamic", ext_name);
                        return false;
                    }
                }
            }
        }

        start = full_pos + 1;
    }

    println!("DEBUG: Only constant extensions found");
    true
}

/// Print admin URLs for all domains and admin keys
fn print_admin_urls(args: &Args) -> Result<(), Box<dyn std::error::Error>> {
    let mut admin_keys = get_admin_keys()?;
    let domains = get_domains(&args.cache_dir)?;

    // Generate keys for any missing extensions
    let available_extensions = get_available_admin_extensions()?;
    println!("DEBUG: Available extensions: {:?}", available_extensions);
    println!("DEBUG: Current admin keys: {:?}", admin_keys.iter().collect::<Vec<_>>());
    let mut needs_update = false;

    for ext_name in available_extensions {
        // Check if any admin path for this extension already exists
        let has_existing_key = admin_keys.iter().any(|key| key.starts_with(&format!("{}_", ext_name)));
        if !has_existing_key {
            println!("Generating admin key for missing extension: {}", ext_name);
            let key_suffix = generate_admin_key_for_extension(&ext_name);
            let admin_path = format!("{}_{}", ext_name, key_suffix);
            admin_keys.insert(admin_path);
            needs_update = true;
        }
    }

    if needs_update {
        save_admin_keys(&admin_keys)?;
    }

    if admin_keys.is_empty() {
        println!("No admin keys found or generated");
        return Ok(());
    }

    println!("Admin URLs:");
    for domain in domains {
        for admin_path in &admin_keys {
            let admin_url = format!("https://{}/{}", domain, admin_path);
            println!("{}", admin_url);
        }
    }

    Ok(())
}

/// Get list of available admin extensions from compiled-in extensions
fn get_available_admin_extensions() -> Result<Vec<String>, Box<dyn std::error::Error>> {
    // Return the list of extensions that are compiled into the binary
    // This matches what's in the generated_extensions.rs file
    Ok(vec![
        "comment".to_string(),
        "upload".to_string(),
        "stats".to_string(),
        "all".to_string(),
    ])
}

/// Generate a unique admin key for a specific extension
fn generate_admin_key_for_extension(ext_name: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};

    let mut hasher = DefaultHasher::new();
    std::time::SystemTime::now().hash(&mut hasher);
    ext_name.hash(&mut hasher);
    format!("{:016x}", hasher.finish())
}

/// Save admin keys to file
fn save_admin_keys(admin_keys: &std::collections::HashSet<String>) -> Result<(), Box<dyn std::error::Error>> {
    let admin_keys_file = std::path::Path::new("/var/lib/easyp/admin_keys");

    // Create parent directory if it doesn't exist
    if let Some(parent) = admin_keys_file.parent() {
        std::fs::create_dir_all(parent)?;
    }

    let mut content = String::new();
    for k in admin_keys {
        // Save keys in the correct format (extension_key)
        content.push_str(&format!("{}\n", k));
    }

    std::fs::write(admin_keys_file, content)?;
    println!("Admin keys saved to file");

    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    debug_extensions_enabled();
    println!("üöÄ easyp HTTPS Server starting - Debug version with enhanced ACME integration");
    let args = Args::parse().unwrap_or_else(|e| {
        eprintln!("Error parsing arguments: {}", e);
        eprintln!("Use --help for usage information");
        std::process::exit(1);
    });

    // Handle --admin-urls option
    if args.admin_urls {
        print_admin_urls(&args)?;
        return Ok(());
    }

    // Initialize simple logging
    if args.verbose {
        log::set_max_level(log::LevelFilter::Debug);
    } else {
        log::set_max_level(log::LevelFilter::Info);
    }

    // Simple console logger without regex dependency
    log::set_logger(&SimpleLogger).unwrap();

    // Create and run server
    let server = OnDemandHttpsServer::new(args).await?;
    server.run().await?;

    Ok(())
}
